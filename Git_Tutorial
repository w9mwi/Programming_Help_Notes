
TO PARSE/VALIDATE XML, USE...
http://www.w3schools.com/dom/dom_validate.asp
http://www.w3schools.com/dom/dom_validate.asp
http://www.w3schools.com/dom/dom_validate.asp

===================================================================================================

HOW TO SET GIT DEFAULT EDITOR
=============================

When you commit files to the git repository, git allows
you to launch an editor so you can add comments to your
git commit.  The following explains how to select the
default git editor.

Run this command:  sudo update-alternatives --config editor

It prompts you with text similar to this:

  Selection    Path               Priority   Status
------------------------------------------------------------
* 0            /bin/nano           40        auto mode
  1            /bin/ed            -100       manual mode
  2            /bin/nano           40        manual mode
  3            /usr/bin/vim.tiny   15        manual mode

The asterisk (*) designates the default git editor.  To keep
the current git editor, just press the <enter> key.  To change
the git editor, type the number shown in the 'Selection' column.

If the editor you want isn't shown in the above list (for example,
the "xed" editor), you can change the git default editor to use
the "xed" editor one of these two ways:

1) Run this command:   git config --global core.editor "xed --wait --new-window"
   ...OR...
2) Add the following text to the ~/.bashrc file.
   export GIT_EDITOR="xed --wait --new-window"

===================================================================================================

WARNING: Beginning in Git 3.0 (to be released 2026 or 2027) the default name of
         the main development branch will change from "master" to "main".  You
         can change this name in Git to any name you wish by using the following
         commands:

         git config --global init.defaultBranch New_Name

         A just-created git branch name can be renamed via this command:

         git branch -m New_Name

===================================================================================================

GIT TUTORIALS:  https://git-scm.com/book/en/v2/
                https://www.atlassian.com/git/tutorials/

CREATE GIT REPOSITORY - FROM YOUR COMPUTER VIA THE COMMAND LINE:
                        1) First, create a new directory.  (This will be the parent directory used
                           to contain the entire software project.)  Next, change the directory
                           (via cd command) so your command line points to this new directory.
                        2) From the command line, run the following:
                           > git init  (This command creates a new git repository by creating a folder named ".git".)
                           > ls .git   (Verify that a new .git folder was created.)
                           > git status (You should now see text that reveals the git status.)
                           > git branch css    (Creates a new branch for this git repository named "css".)
                           > git checkout css  (This command points you to the newly-created "css" branch.)

DELETE GIT REPOSITORY - FROM YOUR COMPUTER VIA THE COMMAND LINE:
                        Navigate to the top-level directory of your software project, which contains the
                        git repository and therefore the ".git" directory.  Then delete the ".git" directory,
                        which deletes the git repository.  The files and directories that were associated with
                        the now-deleted git repository will remain; you must delete them on your own.
                        To delete a specific git branch (NOT the git repository), run the following command(s):
                        > git branch -d test  (-d deletes the branch named "test" ONLY if the branch is fully merged.)
                        ...OR...
                        > git branch -D test  (-D deletes the branch named "test" regardless if the branch is merged or unmerged.)
                        NOTE: You cannot delete the 'main' branch using this command.
                              To delete the 'main' branch, just delete the repository's .git directory.

WORKING DIRECTORY - The top-level directory/folder that contains all files and subdirectories
                    that comprise your software project.

SNAPSHOT/STAGING  - A snapshot represents the state of your project at a given point in time.
                    Git’s term for creating a snapshot is called staging because we can add or remove
                    multiple files before actually committing it to the project history.  Staging gives
                    us the opportunity to group related changes into distinct snapshots--a practice that
                    makes it possible to track the meaningful progression of a software project (instead
                    of just arbitrary lines of code).  Only after executing git commit will our snapshot
                    be recorded in the repository. Committed snapshots can be seen as “safe” versions of
                    the project.  Git will never change them, which means you can do almost anything you
                    want to your project without losing those “safe” revisions.

GIT STATUS          Displays the current status of your local git repository.  EVERY TIME YOU MAKE A
                    CHANGE WITH ANY GIT COMMAND, it's a good idea to run "git status".  This will confirm
                    the change you made was successful.  Or, if you made a mistake with with a git command,
                    running "git status" will tell you more about the error, and possibly how to fix it.
                    > git status

GIT ADD             Before you can commit file(s) to the git repository via the "git commit"
                    command, you must first run the "git add" command on the file(s).

                    You need to run the "git add" command on a file only one time.  Then,
                    whenever you change (or delete) that file in the future, you only
                    need to run the "git commit" command on that file to commit it to the
                    git repository.  If you delete a file that has been added (via the
                    "git add" command), and then your run "git commit" on it, the file
                    is permanently deleted from the git repository.

                    UNSTAGED FILES - Files that haven't been added to the git repository
                                     (via the "git add" command) are called unstaged files.
                                     Unstaged files are not part of the git repository.

                    STAGED FILES - Files that have been added to the git repository (via
                                   the "git add" command) are called staged files.
                                   Staged files are part of the git repository.

                    Below are some examples of how to use the "git add" and "git commit"
                    commands.
                    
                    Add multiple files.
                    > git add index_1.html  index_2.html  index_3.html

                    To execute "git add" on all files in the current directory,
                    run this command:
                    > git add *

                    After a file is staged by running the "git add" command, you must
                    commit the file to the git repository via the "git commit" command.

                    IMPORTANT: To delete a file from the git repository, you must
                               first delete that file in your git repo directory,
                               then run "git commit -a" from your git repo directory.

                    Here are some examples of how to use "git add" along with "git commit".

                    1) Explicitly add, and then commit files to the git repository:

                       > git add    index_1.html  index_2.html
                       > git commit index_1.html  index_2.html

                    2) The following git command does the same as the "git commit" shown
                       immediately above.  If one or more staged files in the directory
                       have been modified since your last "git commit", you can commit
                       all staged files in the directory at once by adding the "-a" flag
                       to the "git commit" command, like this:

                       > git commit -a

GIT COMMIT          To commit all files of your snapshot (files that have been added via
                    the "git add" command) to the git repository, run the following command.
                    The "-a" flag designates all files that have been added to the git
                    repository via the "git add" command.

                    > git commit -a

                   Adding the "-m" (message) flag to "git commit" requires the
                   commit to include a text message between double quotes ("").
                   This is a comment that describes the changes you made.

                   > git commit -a -m "Changed background color of all web pages."

                   NOTE: When a "git commit" includes the "-m" (message) flag,
                         the default git editor won't pop up because the commit
                         message has just been added via the command line.

                   If you want to undo (remove) a previous commit, obtain its SHA-1 log number,
                   then run the following command to undo that commit:
                    > git revert 514fbe7   (514fbe7 is the SHA-1 log number)

                    The following commands will add any number of files/directories from
                    your repository, then commit them to the current branch.  After you
                    add and commit, run "git push" to put them in the remote repository.
                    First, add the files/directories.
                    > git add .  (Don't forget to type the period . char!)
                    > git commit . -m "Added files/directories."
                    > git push
                    To delete any number of files/directories from your repository,
                    commit that change to the current branch, and push it, do this...
                    First, delete the files/directories.
                    > git commit . -m "Deleted files/directories."
                    > git push

                    If you made a mistake with your most-recent commit, you can undo that
                    commit by running the command "git commit --amend", which does the
                    following, in this order:
                       1) undo the previous commit, in which you made a mistake.
                       2) pick up the change(s) you made since the previous commit.
                       3) perform the commit that includes your most recent change(s).

                    EXAMPLE: Assume you performed a "git commit", but you forgot to first run
                             "git add" on 1 of the 3 files you want to be part of that commit.
                              You would fix that by doing the following.
                    > git add file_1
                    > git add file_2   (Assume that you forgot to run "git add file_3")
                    Here we FORGOT to run "git add" on file_3 before running "git commit".
                    > git commit -m "Commit file_1, file_2, file_3."
                    > git add file_3
                    Now that we ran "git add" on file_3, we will amend the commit.
                    > git commit --amend  (Now, all 3 of your files have been added and committed.)

                    If your most-recent commit is all OK, and you run "git commit --amend", it will
                    do nothing except launch the git editor, allowing you to change your git commit
                    message.

GIT FETCH         The "git fetch" command IMPORTS A BRANCH from a remote repository into the repository
                  you're currently pointed to.  Use the "git "fetch" command, followed by the "git merge"
                  command, in place of the "git pull" command.
                  > git fetch
                  > git merge

GIT LOG           Run the following:
                  > git log  (Displays only git commits.)
                  > git log --oneline  (Displays each commit on only one line.)
                  > git log --oneline blue.html  (Displays each commit made on the "blue.html" file.)
                  > git log -n 4  (Displays log for the 4 most-recent commits.)

GIT CONFIG        Run the following commands so git knows your name and e-mail address.  You need to
                  do this ONLY ONCE.  Now when you commit files to your git repository, and you
                  later run "git log", your name and e-mail address will show up in the log output.
                  > git config  --global user.name   "Joe Schmoe"
                  > git config  --global user.email  joeschmoe@yahoo.com

                  To display the current git config settings run the following commands:
                  > git config --list
                  > git config --list --show-origin

GIT CHECKOUT      IMPORTANT: When you checkout a previous snapshot of the current branch via a command like
                             "git checkout 625cdef", you are no longer on any branch!  You can confirm that
                             by running the "git branch" command.  However, you can create a new branch
                             containing this snapshot by next running a command like one of these two commands:
                             "git checkout newBranchName"     (Uses the current snapshot to creates a new branch.)
                             "git checkout -b newBranchName"  (Same as above, except the -b flag also switches to newBranchName.)

                  The "git checkout" command can do the following:

                  1) Checkout (switch to) an existing branch, like this:
                     > git checkout Version_1  (Version_1 is the name of an existing branch.)
                     > git checkout main       (main is name of an existing branch.)

                  2) Checkout a previous snapshot.  First obtain the snapshot number by
                     running the "git log" command, like this:
                     > git log  (3 lines of text will display, similar to the 3 lines below.)
                       commit c9d66dd85f0b6891e5d3f29fc12750e6ca74ad9d
                       Author: TJB <w9mwi@yahoo.com>
                       Date:   Thu Jan 14 20:22:41 2016 -0600

                     Next, run the "git checkout" command containing the snapshot number, like this:
                     > git checkout c9d66dd85f0b6891e5d3f29fc12750e6ca74ad9d

                     You can cancel the previous "git checkout c9d66..." command by running one of the following two commands:
                     > git switch -
                     ...OR...
                     > git checkout branchName   (Returns to the "branchName" branch, canceling the above "git checkout c9d66...")

                  3) Create a new branch named poop, AND switch to the new poop branch, like this:
                     > git checkout -b poop

GIT INIT         After you create a new folder for a new software project, you need to run
                 the following command inside that folder

                 git init

                 Running that command creates the following 4 folders:

                 hooks - This directory contains scripts that Git executes automatically at key points
                         in the development lifecycle, such as before a commit (pre-commit), after a
                         commit (post-commit), or before a push to a remote repository (pre-push).
                         These hooks allow developers to customize Git's behavior, automate tasks
                         (like running tests or linting code), and enforce project standards.
                         The directory initially contains sample scripts that need to be renamed
                         (by removing the .sample extension) and made executable to be activated.

                 info - This folder contains miscellaneous repository information that doesn't fit
                        elsewhere.  The most notable item inside is the exclude file, which acts
                        like a local, per-repository .gitignore file.  Patterns listed in info/exclude
                        specify files that Git should ignore, but unlike .gitignore, these ignored
                        patterns are not committed to the repository or shared with others.

                objects - This is the core of Git's storage system, functioning as the object database
                          where all the project's content is stored.  Every version of every file, along
                          with commits and directory structures, is stored here as a compressed object
                         (specifically blob, tree, commit, and tag objects). Each object is stored as
                         a file named by its unique SHA-1 hash, ensuring data integrity.  Git stores
                         objects in subdirectories using the first two characters of their hash to manage
                         the number of files in a single directory.
                refs -   This directory stores pointers to commit objects, providing human-readable names
                         for specific points in the project's history. It is typically organized into
                         subdirectories:
               refs/heads - Contains files representing your local branches, where each file holds the
                            SHA-1 hash of the most recent commit on that branch.
               refs/tags  - Stores information about annotated and lightweight tags, which are used to
                            mark specific milestones or releases.
               refs/remotes - This folder exists only in cloned repositories.  Stores the references
                              for remote branches, tracking the state of branches on remote repositories.

GIT TAG          To view the list of existing tags, execute this command:
                 > git tag
                 To tag a release on a branch called "main", do the following:
                 > git checkout main  (First, checkout the branch you want to tag.)
                 > git tag -a Version_1.0  -m "Tag Version 1.0"
                 The -a flag tells Git to create an annotated tag, which allows
                 us to record our name, the date, and a descriptive message
                 (specified via the -m flag).

                 To view the message entered via a "git tag", run the following command:
                 > git show v1.0   (Shows the message entered when the v1.0 tag was created.)

                 When you want to return to the "Version_1.0" tag, you can run the following command
                 instead of "git checkout c9d66dd8...", which involves the long, cumbersome ID number.
                 > git checkout Version_1.0

GIT REVERT        Undoes (removes) the changes made in one of the previous commits.  When using the
                  "git revert" command, make certain you use the ID of the commit you want undone,
                  and NOT the ID of the commit you want to return to.
                  > git checkout main  (Checkout the name of the branch you want to revert.  In this example it's "main".)
                  > git log            (Obtain the snapshot ID of a previous commit that you want undone,
                                        which will be used in the "git revert" command below.)
                  > git revert b1b4e7a7  (This removes the changes made in ID "b1b4e7a7...".)

GIT RESET         NOTE: "git restore" is a NEW alternative command to "git reset", and should be used
                        instead of "git reset".  See "git restore" command below for details.

                  "git reset" undoes changes to the working directory and the staged snapshot.  Assume you
                  made text changes to an already-committed file named index.html AND you added a brand-new
                  file named "dummy.html".  If you decide to scrap those changes (that is, revert changes
                  made to index.html AND delete the "dummy.html" file), run the following 2 commands.
                  NOTE: Both of the following commands ("reset" and "clean") affect the ONLY THE WORKING DIRECTORY.
                        The "git reset" command also reverts changes made to the STAGED SNAPSHOT, which is made
                        via the "git add" command.  The following 2 commands DON'T change the contents of any
                        committed snapshots.
                  > git reset --hard  (Resets TRACKED files, not STAGED files, to match the most recent commit.)
                  > git clean -f  (Deletes all UNTRACKED files from the working directory.)
                  The above 2 (TWO) commands together permanently undoes uncommitted changes.
                  The "git reset --hard" command removes the uncommited change made to index.html.
                  The "git clean -f" command deletes the dummy.html file that you added (but didn't
                  "add" or "commit").  "git clean -f" is equivalent to manually deleting all files
                  that haven't been added or commited.


GIT RESTORE       NOTE: The "git restore" command was introduced in git Version 2.23.0, and is an alternative
                  to the "git reset" command.  "git restore" can be a dangerous command because it can
                  permanently delete files.  Be careful how it's used.

                  Assume you’ve changed files named file_1 and file_2, and want to commit them as two separate changes.
                  However, you mistakenly ran "git add *" and staged both those files.  The following shows how
                  to unstage file_2.

                  > git add *  (You mistakenly staged the file named file_2.)
                  > git restore --staged file_2

GIT CLEAN         Assume you created a new file named dummy.html.  But you didn't add or commit it to git, which
                  means dummy.html is NOT tracked.  To remove this dummy.html file AND ALL UNTRACKED FILES, run:
                  > git clean -f  (Deletes all untracked files from the working directory.)

GIT SWITCH       The "git switch" command introduced was introduced in Git Version 2.23.  It's used mainly for
                 creating and switching branches.  It's an alternative to the "git checkout" command.

                 The below command includes the hyphen '-' character.  It cancels the last
                 "git checkout" command, and returns you to the previous branch.
                 > git switch -

GIT BRANCH       Understand the following branching example.  It shows how to make a change to an
                 existing branch (the "main" branch), and then commit that change to a new branch
                 named "crazy" WITHOUT CHANGING THE EXISTING BRANCH.  (In this example, not changing
                 the "main" branch.)

                 1) Assume we're on branch "main" and it's up to date.  So if you run "git branch",
                    the output text says:
                    * main

                 2) Checkout a previous commit, like this:
                    > git checkout 16ec1dd  (Several lines of text will be output similar to the following.)

                    Note: switching to '16ec1dd'.

                    You are in 'detached HEAD' state...
                    ... More text here ...
                    HEAD is now at 16ec1dd Add a crazy.html
       
                 3) Check the current status.
                    > git status  (Text similar to the following will be output.)
                    HEAD detached at 16ec1dd
                    nothing to commit, working tree clean

                 4) Next, run the following 2 git commands:
                    > git branch crazy  (Creates a new branch named "crazy".  Outputs no text.)
                    > git branch        (Outputs the following 3 lines of text, showing were NOT ON ANY BRANCH!)
                    * (HEAD detached at 16ec1dd)
                    crazy
                    main

                 5) The following command makes the current working directory (containing the "HEAD detached"
                    state) become the "crazy" branch.
                    > git checkout crazy  (Outputs the following line of text.  Designating the previous "git checkout" has now been committed to the "crazy" branch.)
                    * crazy
                    main
                 =======================================================

                 To view all local git branches on your computer (not remote branches),
                 run the following command.

                 > git branch

                 The above command displays text similar to the text below, where the
                 asterisk (*) designates the git branch that is currently checked out.

                   verson_1_branch
                 * main

                 TO DELETE AN EXISTING BRANCH - The following example shows how to delete
                 a branch named "css".  For this to work, you must currently be pointed
                 to some branch other than the "css" branch.

                 > git branch -d css  (-d deletes the css branch ONLY if it has been fully merged into the main branch.)
                 > git branch -D css  (-D deletes the css branch regardless if it has, or hasn't, been merged.)

                 TO CREATE A NEW BRANCH - The example below shows how to create a new branch named poop,
                 and how to then checkout this new branch.  This new poop branch will initially be
                 identical to the branch you're currently pointed to when you run the checkout command.

                 > git branch poop    (Creates the "poop" branch, which will be identical to the branch currently checked out.)
                 > git checkout poop  (Switch from the current branch to the new poop branch.)

                 The following "git checkout" command performs both of the above commands in a single command.
                 > git checkout -b poop

                 In Git, a branch is an independent line of development.  Branches present an error-proof method for
                 incorporating changes from an experiment.  Branches also let you store all of your experiments in a
                 single directory, which makes it much easier to keep track of them and to share them with others.
                 Creating a new branch is really just a way to request an independent working directory, staging
                 snapshot, and history.  There are four (4) core elements to work with throughout the rest of this tutorial:
                 1) The Working Directory
                 2) The Staged Snapshot
                 3) Committed Snapshots
                 4) Development Branches
                 When the "git branch" command creates a new branch, it uses the current HEAD NODE as the starting point
                 for the new branch.  This means the new branch begins as a copy of the existing branch--so it will contain
                 a copy of the existing branch's files located in the current working directory.
                 
                 Git uses the tip of a branch to represent the entire branch.  In other words, a branch is actually
                 a pointer to a single commit—-not a container for a series of commits.

                 The following command displays our one and only branch: * main.  The main branch is Git’s default
                 branch, and the asterisk next to it tells us that it’s currently checked out.  Notice that since
                 there’s only one working directory for each project, only one branch can be checked out at a time.
                 > git branch
                 * main  (This gets displayed when "git branch" is run.)
                 Next, check out a previous snapshot (514fbe7 referes to the ID of the crazy.html commit.)
                 > git checkout 514fbe7
                 From this, let's now create a new branch called "crazy":
                 > git branch crazy
                 And now, let's checkout this new "crazy" branch so we'll no longer be on the "main" branch.
                 > git checkout crazy
                 The new "crazy" branch is a completely isolated from the "main" branch, so we can
                 mess with files in this same working directory without changing any files on the "main" branch.

                 Rename crazy.html to rainbow.html, then use the following Git commands to update the repository.
                 > git status
                 > git rm crazy.html
                 > git status
                 > git add rainbow.html
                 > git status
                 > git commit -m "Rename crazy.html to rainbow.html"
                 The git rm command above tells Git to stop tracking crazy.html (and delete it if necessary), and the
                 git add command above starts tracking rainbow.html.  The renamed: crazy.html -> rainbow.html message
                 in the "git status" output shows us that Git is smart enough to figure out when we’re renaming a file.
                 Now, when we run "git branch", we see both branches (crazy and main) that exist:
                 > git branch
                     crazy
                   * main

GIT MERGE       When you perform a merge, you are always merging some other branch into the
                branch that is currently checked out.  Therefore, the "git merge" command
                affects ONLY the branch that is currently checked out.

                > git checkout main  (Go to the main branch.)
                > git merge css      (Merges the css branch into the main branch.)

                There are simple merges (also known as a Fast-Forward merge), and there are 3-Way Merges.  A Fast-Forward
                merge performs a ONE-PARENT COMMIT.  A 3-Way Merge occurs when you try to merge two branches that have a
                divergent history.  A 3-Way Merge performs a TWO-PARENT COMMIT.  To put it another way...

                When the "git merge" command is used, the merge performed is one of the following two (2) types:

                1) Fast-Forward Merge - Assume you're on the "main" branch and you want to merge a branch
                                        named "css" into the "main" branch.  If the "css" branch contains
                                        all the code contained in the "main" branch, plus additional code,
                                        the "git merge css" command will perform a Fast-Forward Merge.  The
                                        result will be that the HEAD of the "main" branch will point to
                                        the same location as the HEAD of the "css" branch.  To see an example
                                        of this, go to this web URL:
                                        https://hamwaves.com/collaboration/doc/rypress.com/branches-1.html
                        
                                        Next, compare the image contained directly below this text:
                                        This results in a repository history that looks like:

                                        ...with the image contained directly below this text:
                                        now matches the snapshot pointed to by the main branch.

                                        Viewing those two images, notice that the HEAD of the "main" branch is
                                        "fast forwaded" to the HEAD of the "css" branch.  So when the "git merge css"
                                        command is run, NO new commit is performed.

                2) 3-Way Merge        - Assume you're on a branch named "crazy" and you want to merge the branch
                                        named "main" into the "crazy" branch.  Only some (not all) of the code
                                        contained in the "main" branch is contained in the "crazy" branch.
                                        When that condition occurs, a Fast-Forward Merge is impossible; so
                                        running "git merge main" will instead perform a 3-Way Merge.  To see
                                        an example of this, go to this web URL:
                                        https://hamwaves.com/collaboration/doc/rypress.com/branches-2.html

                                        Next, view the "Before" and "After" images contained directly above this text:
                                        Merging main into the crazy branch.

                                        Notice the HEAD of the "main" branch remains unchanged, and the "crazy"
                                        branch points to a newly-created HEAD, which points to BOTH the PREVIOUS HEAD
                                        of the "crazy" branch AND to the "main" branch.  Since a new HEAD was
                                        created via the "git merge main" command, a new commit was also generated.

                                        For another explanation of a git 3-Way Merge, view the following web URL.
                                        SEE --> https://www.tutorialspoint.com/what-is-3-way-merge-or-merge-commit-in-git

GIT REBASE    Rebasing allows you to move branches around by changing the commit that they are based on.
              (Thus the name rebase.)

              Git rebase requires you to be on the branch that you want to alter.  In this example,
              we must be on the 'about' branch.  Running the 'git rebase main' command will then
              alter the 'about' branch so its TAIL NODE will now connenct to the HEAD NODE of the
              'main' branch.
              > git checkout about
              > git rebase main

              An INTERACTIVE REBASE prompts the user with an opened text file, which can be edited to alter how the
              rebase performs.  If the user does NOT alter this text file, the rebase that occurs will be identical
              to running the 'git rebase' command WITHOUT the -i flag shown below.  To run an interactive rebase on
              the 'about' branch, do the following:
              > git checkout about
              > git rebase -i main  (The -i flag menas INTERACTIVE, so the user will be prompted to change behavior.)
              
              If you're in the middle of performing a rebase, and you get lost (not certain if what you're doing
              is correct), you can abort rebase in midstream by running the following command:
              > git rebase ‑‑abort

              Rebasing enables fast-forward merges by moving a branch to the tip of another branch.  It effectively
              eliminates the need for merge commits, resulting in a completely linear history.  To an outside observer,
              it will seem as though you created every part of your project in a neatly planned sequence, even though
              you may have explored various alternatives or developed unrelated features in parallel.  Rebasing gives
              you the power to choose exactly what gets stored in your repositories.

GIT REFLOG    Git uses something called the reflog to record every change you make to your repository.  The reflog is
              a chronological listing of repository history, without regard for the repository’s branch structure.
              This lets us find dangling commits that would otherwise be lost from the project history.  Run the
              following command, which will display a list of history:
              > git reflog

GIT RM - This command tells git to stop tracking a file.  Assume you're on some git branch and want to
         edit a file named crazy.html, and then rename that file to rainbow.html.  You would do this...

         Edit and save the crazy.html file.
         > mv crazy.html rainbow.html
         > git rm crazy.html    (Inform git to no longer track the crazy.html file)
         > git add rainbow.html
         > git commit -m "Added rainbow.html file and deleted the crazy.html file."

REMOTE REPOSITORIES  A remote repository is one that's not your own.  It can be another Git repository located
                     on your company’s network, the internet, or even on your own hard disk.  Remote branches
                     act just like local branches, except they represent a branch located in someone else’s repository.
                     Think of REMOTE BRANCHES AS READ-ONLY BRANCHES.   If you approve the changes a remote branch contains,
                     you can merge it into a local branch with a normal git merge. 

CLONING REPOSITORY  To clone an existing repository located on your hard disk, do the following...
                    On the command line, navigate to the PARENT DIRECTORY containing the repository
                    you want to clone.  In this example, the "C:\Tom\Programming" parent directory
                    contains the child directory "C:\Tom\Programming\my-git-repo".  So navigate to
                    the "C:\Tom\Programming" directory, then run the following commands:
                       > git clone my-git-repo  marys-repo  (The my-git-repo directory/repository gets cloned into the
                                                             marys-repo directory/repository.  This command also creates
                                                             the marys-repo directory.)
                       > cd marys-repo  (You are now in the newly-created repository directory named marys-repo.)
                       > git branch -rv (Verify that the only LOCAL BRANCH existing in marys-repo is the 'main'
                                         branch.)
                       > git remote -v  (Verify the marys-repo BRANCH does have a REMOTE REPOSITORY named 'origin'.  This
                                         REMOTE REPOSITORY named 'origin' was created via the above "git clone" command.)
                       > git config user.name "Mary"
                       > git config user.email w9mwi@yahoo.com
                    When you clone a repository, Git automatically adds an 'origin' REMOTE REPOSITORY to the newly-cloned
                    repository.

                    Next, navigate back to the "C:\Tom\Programming\my-git-repo" directory, and run the following commands:
                       > git remote -v (Notice that there exists no remote repository.)
                       > git remote add mary ../marys-repo   (Create a remote repository named 'mary', pointing to the
                                                              repository located in "C:\Tom\Programming\marys-repo")
                       > git remote -v  (The following 2 lines are output.)
                       mary    ../marys-repo (fetch)
                       mary    ../marys-repo (push)
                    IMPORTANT: From the "C:\Tom\Programming\marys-repo" directory, we can now reference the 'origin'
                               repository.
                    IMPORTANT: From the "C:\Tom\Programming\my-git-repo" directory, we can now reference the 'mary'
                               repository.

MERGING FROM ONE REPOSITORY INTO ANOTHER:
                    After you've completed all steps in the above CLONING REPOSITORY section, do the following
                    to merge code from the 'mary' repository (located in the 'marys-repo' directory) into the
                    'origin' repository (located in the 'my-git-repo' directory).
                    From the "C:\Tom\Programming\my-git-repo" directory, run these commands:
                       > git fetch mary  (Fetch all of the branches located in the marys-repo repository into
                                          the my-git-repo repository.)
                       > git branch -rv  (Displays all branches that exist in REMOTE REPOSITORIES, like the following
                                          2 lines.)
                         mary/bio-page
                         mary/main
                   Let's now checkout the mary/main branch (displayed immediately above) into the my-git-repo directory.
                       > git checkout mary/main  (Checkout the main branch from the mary repository,
                                                 so we can review code changes made by Mary.)
                       > git checkout main       (Checkout our own main branch, which overwrites the mary/main
                                                 branch that we just checked out in the previous command.)
                       > git merge mary/main     (Merge the mary/main branch into our main branch.)

FETCH AND PUSH    The "git fetch" and "git push" push commands are almost opposites.  Fetch IMPORTS A BRANCH from
                  a remote repository.  The "git push" command exports a branch to another repository, as it also
                  CREATES A NEW LOCAL BRANCH in that remote repository.  Navigate to the "C:\Tom\Programming\my-git-repo"
                  directory, and run the following 2 commands.
                  > git branch dummy     (Creates a new 'dummy' branch in the my-git-repo directory.)
                  > git push mary dummy  (Export the 'dummy' branch to the 'mary' repository.)
                  As a general rule, you should never push into another developer’s repository.  The reason "git push" exists
                  is that it allows you to make changes to a PUBLIC repository, that should be maintained by multiple people.
                  Next, navigate to the "C:\Tom\Programming\my-git-repo" directory, tag the main branch in this
                  directory, and then push this tagged v2.0 version to the 'mary' repository.
                  > git tag -a v2.0 -m "An even stabler version of the website"
                  > git push mary v2.0
                  Navigate to the "C:\Tom\Programming\marys-repo" directory, and run the following command.
                  > git tag  (The 'v2.0' tag should display.)
                  It’s very easy to forget to push new tags, so if it seems like your project has lost a tag or two,
                  it’s most likely because you didn’t to push them to the remote repository.
                  Note that "remotes" are for people.  "Branches" are for topics.  Do not create separate branches
                  for each of your developers—-give them separate repositories and bookmark them with git remote add.
                  Branches should always be for project development, not user management.  The 'git push' command works
                  ONLY if you cloned from a server to which you have write access, AND IF nobody has pushed in the
                  meantime.  If you and someone else clone at the same time, and they push upstream, and then later you
                  push upstream, your push will rightly be rejected.  You’ll have to pull down their work first and
                  incorporate it into yours before you’ll be allowed to push.

GIT FETCH         The "git fetch" command IMPORTS A BRANCH from a remote repository into the repository
                  you're currently pointed to.  Since fetched content is represented as a remote branch,
                  it has absolutely no effect on your local development work. This makes fetching a safe
                  way to review commits before integrating them with your local repository.  It’s similar
                  to an "svn update" in that it lets you see how the central history has progressed, but
                  it doesn’t force you to actually merge the changes into your repository.

                  SUMMARY...
                  > git clone <remote-path>  (Create a copy of a remote Git repository.)
                  > git remote -v  (List remote repositories.)
                  > git remote add <remote-name> <remote-path>  (Add a remote repository.)
                  > git remote show origin  (Show details about the remote branch named 'origin'.)
                  > git fetch <remote-name>  (Download remote branch information, but do not merge anything.)
                  > git merge <remote-name>/<branch-name>  (Merge a remote branch into the checked-out branch.)
                  > git branch -rv  (List remote branches.)
                  > git push <remote-name> <branch-name>  (Push a local branch to another repository.)
                  > git push <remote-name> <tag-name>     (Push a tag to another repository.)

CENTRALIZED WORKFLOWS
                  Running the below "git init" command creates a new repository directory named central-repo.git.  The
                  --bare flag indicates there will NOT be a working directory created for this repository.  If you navigate
                  to the C:\Tom\Programming\central-repo.git directory, you'll see it does NOT contain the standard
                  .git directory.  As a matter of fact, the files contained in this C:\Tom\Programming\central-repo.git
                  directory contain the same files that exist in the standard .git directory.  (That's why we this
                  directory name contains the ".git" extension.)  Not having a working directory prevents anyone
                  from developing in the central repository, which eliminates the possibility of messing up another
                  user’s environment with git push.  A central repository should act only as a storage facility--not
                  as a development environment.
                  > git init --bare central-repo.git
                  Add this new central repository (central-repo.git) as a REMOTE REPOSITORY to both the 'marys-repo' and
                  the 'my-git-repo' repositories by running the following commands:
                  > cd marys-repo  (Navigate to the C:\Tom\Programming\marys-repo directory).
                  > git remote rm origin  (Delete the existing remote repository named 'origin'.)
                  > git remote add origin ../central-repo.git  ('marys-repo' now references central-repo.git as 'origin'.)
                  > cd my-git-repo  (Navigate to the C:\Tom\Programming\my-git-repo directory).
                  > git remote add origin ../central-repo.git  ('my-git-repo' now references central-repo.git as 'origin'.)
                  > git remote rm mary  (Remove the existing 'mary' remote epository from my-git-repo.)
                  Now, push the main branch of the my-git-repo repository to the central-repo.git repository.
                  > cd C:\Tom\Programming\my-git-repo
                  > git push origin main  (The central-repo.git main branch gets a copy of the my-git-repo main
                                             branch.)
                  > cd C:\Tom\Programming\central-repo.git
                  > git log  (Confirm that the output of this log is identical to the log output on the my-git-repo
                              repository.
                  NOTE: The "git push" command creates a local branch in the destination repository.  It's dangerous to
                        push to a friend’s repository, as she probably won’t appreciate other programmers creating new
                        branches in her working directory without her consent.   However, it’s safe to create local
                        branches in central-repo.git because it has no working directory, which means it’s impossible
                        to disturb anyone’s development.
                  WARNING:  NEVER rebase commits that have been pushed to a shared repository.  If you need to change
                            a public commit, use the "git revert" command discussed previously.
DISTRIBUTED WORKFLOWS
                  Run the following commands:
                  > cd C:\Tom\Programming\my-git-repo
                  > git remote rm  origin  (Delete the existing remote 'origin' branch from the my-git-repo directory.)
                  > git remote add origin https://github.com/w9mwi/my-git-repo.git  (Point the remote 'origin' repository
                                                                                     to GitHub.)
                  > git push origin main  (Push my-git-repo's main branch to the remote 'origin' (GitHub) branch.
                  Create a repository for co-worker John:
                  > cd C:\Tom\Programming
                  > git clone  https://github.com/w9mwi/my-git-repo.git  johns-repo  (johns-repo will contain our
                                                                                      GitHub contents.)
                  > cd johns-repo
                  > git config user.name "John"
                  > git config user.email junk@shit.com
                  > git checkout -b pink-page  (Creates a new branch named pink-page, and then does a checkout on pink-page.)
                  Add a new repository to GitHub named 'johns-repo' via the GitHub web site.  Next, on your hard disk, inside
                  the C:\Tom\Programming\johns-repo directory, run the following command to create a new remote repository
                  named 'john-public', which will point to the new 'johns-repo' repository on GitHub.
                  > git remote add  john-public  https://github.com/w9mwi/johns-repo.git
                  From the C:\Tom\Programming\johns-repo directory, make certain you have the 'pink-page' branch checked out.
                  Then, push the pink-page local branch to the 'john-public' remote branch that's located on GitHub...
                  > cd C:\Tom\Programming\johns-repo
                  > git checkout pink-page
                  > git push john-public pink-page  (Creates new 'pink-page' repository from GitHub in
                                                     C:\Tom\Programming\johns-repo)
                  In the my-git-info directory, add a new remote repository named 'john' that points to 'johns-repo'
                  in GitHub...
                  > cd C:\Tom\Programming\my-git-repo
                  > git remote add john  https://github.com/w9mwi/johns-repo.git
                  > git fetch john  (Copies contents of GitHub's 'johns-repo' repository to the new 'john' repository.)
                  > git branch -rv  (Shows the new john/pink-page remote repository.)
                  > git checkout john/pink-page  (Checkout the 'pink-page' repository located in
                                                  C:\Tom\Programming\johns-repo)
                  If you approve John's updates, merge them into your main branch (in the my-git-repo directory).
                  > git checkout main
                  > git merge john/pink-page
                  Finally, push your main branch to the 'origin' GitHub 'my-git-repo' repository, which corresponds
                  to your 'my-git-repo' working directory.
                  > git push origin main
                  Do the following on the 'marys-repo' branch.
                  > cd C:\Tom\Programming\marys-repo
                  > git remote rm origin  (Delete the previous 'origin' branch, as we make a new one that points to GitHub.)
                  > git remote add origin  https://github.com/w9mwi/my-git-repo.git  (Creates new 'origin' branch pointing
                                                                                      to GitHub.)
                  > git checkout main
                  > git fetch origin  (Copies contents of GitHub's 'my-git-repo' repository to the new 'origin' repository.)
                  > git rebase origin/main
                  Update johns-repo on your hard disk, similar to what we did with marys-repo above.
                  > cd C:\Tom\Programming\johns-repo
                  > git checkout main
                  > git fetch origin
                  > git rebase origin/main

PATCH WORKFLOWS  Add a remote branch named 'origin' to BOTH the my-git-repo and the marys-repo repositories.
                 Both these remote branches named 'origin' will point to the same remote repository.
                 > cd C:\Tom\Programming\my-git-repo
                 > git remote add origin https://github.com/w9mwi/my-git-repo.git
                 > cd C:\Tom\Programming\marys-repo
                 > git remote add origin https://github.com/w9mwi/my-git-repo.git

TIPS AND TRICKS
                 Archive the 'main' repository in the 'my-git-repo' directory (not including the .git directory).
                 Removing the .git directory removes all version control information, and you’re left with a single
                 snapshot of your project.
                 > cd C:\Tom\Programming\my-git-repo
                 > git archive main --format=zip --output=../website-12-10-2012.zip  (On Windows)
                 > git archive main --format=tar --output=../website-12-10-2012.tar  (On UNIX)
                 You can also bundle a repository, which is similar to the above 'archive' command, except the resulting
                 file does contain the .git directory (versioning information of the entire project).  In this example,
                 we bundle the 'main' branch of the 'my-git-repo' directory.
                 > git bundle create ../repo.bundle main  (Saves 'main' branch of the repository to the repo.bundle file.)
                 Navigate to the directory containing the repo.bundle file created in the above command, and run the
                 following:
                 > git clone repo.bundle repo-copy -b main  (Creates a cloned repository in a child directory named 'repo-copy'.)
                 Use the bundle command above to backup an entire Git repository.
                 MAKE GIT IGNORE FILES
                 To make Git ignore certain files, you can do the following:
                 > notepad junkfile.txt  (Create a new file called 'junkfile.txt' and save it in the 'my-git-repo' directory.)
                 > git status  (Notice the junkfile.txt appears as an untracked file.)
                 In the same 'my-git-repo' directory, create a new file called .gitignore and enter this text into it:
                 junkfile.txt
                 > git status (junkfile.txt no longer appears as an untracked file, but the .gitignore file does!
                               Fix that here...)
                 > git add .gitignore
                 > git commit -m "Add .gitignore file"
                 > git status  (Notice there are no more untracked files.)

PLUMBING         Running the following command will output the complete representation of a commit, which consists of:
                 Tree + Parent + User Data + Commit Message
                 > git cat-file commit HEAD
                 A tree object is Git’s representation of the “snapshots”. A snapshot records the state of a directory
                 at a given point, without any notion of time or author.  To tie trees together into a coherent project
                 history, Git wraps each one in a commit object and specifies a parent, which is just another commit.
                 By following the parent of each commit, you can walk through the entire history of a project.
                 Run the below commands
                 > git log --oneline  (Obtain an ID number used by the following comand.)
                 > git cat-file tree 781e5cd  (Notice output contains ugly binary cruft.)
                 > git ls-tree 781e5cd        (Output looks much cleaner than above command.)
                 Regarding the output of the above 2 commands: a 'blob' represents a file, a 'tree' represent a folder.
                 Since a blob represents a file, obtain an ID number from the following command that represents a blob.
                 > git cat-file blob 3c13974  (Obtain a an ID from one of the blob files that display.)
                 > git cat-file blob 30560188ea822a5c0fe050eccac16d8ffe47e470  (Prints file contents.)
                 IMPORTANT: A detached HEAD state occurrs when HEAD doesn't coincide with the tip of any branch.
                 Run the following to see this...
                 > git checkout HEAD~1
                 > git status  (You should see a message siminar to this:  HEAD detached at 1287d48)
                 > git checkout main
                 > git status  (The 'HEAD detached' message above should now be gone.)

HOOKS             Read section titled 'Hook into Git’s Internals' on this web page:
                  http://rypress.com/tutorials/git/tips-and-tricks
                  Navigate to the ./git/hooks directory in your repository folder.  You will notice about 9 file names that
                  end with the .sample extension.  These are shell script files.  When the '.sample' extension is removed
                  from these file names, these files will execute the shell script contents of these files.

VIEW DIFFS BETWEEN COMMITS
                  The git diff command is incredibly useful for pinpointing contributions from other developers.  EXAMPLES:
                  > git diff  (Generates a detailed view of all uncommitted changes.)
                  > git diff --cached  (The --cached flag generates a diff between the staged snapshot and most-recent
                                        commit.)
                  > git diff HEAD~2..HEAD~1
                  > git diff main..john/pink-page

========================================================================================================================
========================================================================================================================
HOW TO PUSH YOUR LOCAL HARD DISK REPOSITORY FILES TO A REMOTE GITHUB REPOSITORY
-------------------------------------------------------------------------------

1) Create a new repository on GitHub named tomsJunkRepo, and leave it empty.
2) Run the following:
   > cd C:\Tom\Programming  (The local hard disk directory that will contain your new local repository.)
   > mkdir tomsJunkRepo
3) In the tomsJunkRepo directory, create the .gitignore file, create some other files, and create some files in a
   child directory.  Then create a new 'main' branch in your local repository by running the following commands:
   > cd C:\Tom\Programming\tomsJunkRepo
   > git init  (Creates your local Git repository.)
   > git status (Confirm your local repository was created.)
   > git add .  ...OR...   > git add *   (Adds all untracked files to staging area.)
   > git status (Confirm your files and child directories were added/staged.)
   > git branch -v (Confirm there does NOT yet exist a local branch.)
   > git commit -m "Initial commit."
   > git status  (Confirm the above 'git commit' command has created a branch named 'main'.)
   > git branch -v  (Confirm you're now on this 'main' branch.)
4) Create a new remote repository named 'origin', which will point to your GitHub repository designated by the URL below.
   > git remote -v  (Confirm that there does NOT yet exist any remote repositories.)
   > git remote add origin  https://github.com/w9mwi/tomsJunkRepo.git  (VIA URL, adds a new remote repository named
                                                                        'origin'.)
   > ...OR...
   > git remote add origin  git@github.com:w9mwi/tomsJunkRepo.git  (VIA SSH, adds a new remote repository named 'origin'.
                                                                    Generate new SSH key:
                                                                    https://help.github.com/articles/generating-a-new-ssh-key)
   > git remote -v  (Confirm there now exists a remote repository named 'origin'.)
5) Look at the contents of the 'tomsJunkRepo' repository on your github.com web page, and notice it does NOT contain
   any of the files/directories contained in your local 'tomsJunkRepo' repository.
6) Push the contents of your local 'tomsJunkRepo' repository to the GitHub web site by running the following commands:
   > git branch -rv (Confirm there does NOT yet exist any remote branches--even though the 'origin' remote repository
                     does exist.)
   > git push origin main  (Push the contents of your local 'main' branch to the 'origin' remote repository.)
   > git branch -rv  (Confirm that there now exists a REMOTE repository/branch named origin/main.)
   > git remote show origin  (Prints details about the remote 'origin' repository, similar to the following 8 lines of text.)
     * remote origin
       Fetch URL: https://github.com/w9mwi/tomsJunkRepo.git
       Push  URL: https://github.com/w9mwi/tomsJunkRepo.git
       HEAD branch: main
       Remote branch:
         main tracked
       Local ref configured for 'git push':
         main pushes to main (local out of date)
7) Look at the contents of the 'tomsJunkRepo' repository on your github.com web page, and notice it now DOES CONTAIN
   the files/directories contained in your local 'tomsJunkRepo' repository.
8) THE END - Your local 'main' branch has successfuly been pushed to the 'main' branch of the REMOTE repository named 'origin'.

HOW TO FETCH+MERGE FILES CHANGES MADE ON GITHUB TO YOUR LOCAL 'MAIN' BRANCH
-----------------------------------------------------------------------------
1) Change some text in your files on GitHub.  We'll now fetch+merge these GitHub files to the corresponding files
   on your local 'main' branch.
> git checkout main  (Make certain you're on the local 'main' branch.)
> git remote show origin  (Show details about the remote 'origin' repository.)
> git fetch origin     (Import file changes made on 'origin' remote repo. to your local 'main' branch.
                        NOW DO A GIT MERGE...)
> git merge origin/main  (Only after you run this command will you notice that your files on the local 'main' branch
                            now reflect the files located on GitHub.)
2) THE END - File changes made on the GitHub web site have now been fetched+merged into your local 'main' branch.



HOW TO PUSH FILE CHANGES MADE ON YOUR LOCAL 'MAIN' BRANCH TO THE GITHUB WEB PAGE.)
------------------------------------------------------------------------------------
> checkout main  (Make certain you're on the local 'main' branch.)
1) Change content of some files on your local 'main' branch, then run the following commands:
   > git status  (Shows the files that you changed.)
   > git add .  (Stage the changed files.)
   > git commit -m "Modified the 4 text files."
   > git status  (Verify all the repository is "clean", which means all files have been committed.)
   > git push origin main
2) Verify that all files changed on your local 'main' branch have been pushed to the GitHub web page.
3) THE END

========================================================================================================================
========================================================================================================================

An UNTRACKED FILE is a file that's never had the "git add" command run on it.
A TRACKED FILE is a file that has had the "git add" command run on it at least one time.
A STAGED FILE is a file that has NOT been altered/changed since it was last committed
via the "git commit" command.  Every time you make a change to a STAGED FILE, you must
again run the "git add" command on it before it can be committed via the "git commit" command.

GIT CHECKOUT BRANCHES
> git checkout main  (The repository points to the 'main' branch.)
> git checkout poop    (The repository points to the 'poop' branch.)
> git log --oneline  (Prints something similar to below text.)
  6715fc5 Added whitespace to blue.html file.
  430d978 Add .gitignore file
  49f80f3 Changed index.html, added news4.html.
  fe17adf Add pink page
  1287d48 Add CSS styles for headings and links
> git checkout 49f80f3  (This makes your working directory match the exact state of the 49f80f3 commit.  HEAD no longer
                         points to a branch, but to a previous commit deignated by the 49f80f3 ID.  This is called a
                         “detached HEAD” state.)
> git checkout 6715fc5 blue.html  (Checks out the blue.html file that was in the 6715fc5 commit.  This can change the
                                   current state of your project.  You can add + commit this olded blue.html file,
                                   or run the following command to revert that file back to its current state.)
> git checkout HEAD blue.html     (Returns contents of blue.html file to the one in the most-recent commit.)


GIT CHECKOUT A FILE
> git checkout fe17adf hello.py

GIT PUSH - The most common use case for git push is to publish your local changes to a central repository.  After you’ve
           accumulated several local commits and are ready to share them with the rest of the team, you (optionally)
           clean them up with an interactive rebase, then push them to the central repository.
           'git push' is how you transfer commits from your local repository to a remote repo.  It's the counterpart
           to git fetch.  But whereas 'GIT FETCH' IMPORTS COMMITS TO LOCAL BRANCHES, 'GIT PUSH' EXPORTS COMMITS TO
           REMOTE BRANCHES.  'GIT PUSH' HAS THE POTENTIAL TO OVERWRITE CHANGES, so you need to be careful how you
           use it.  To prevent you from overwriting commits, Git won’t let you push when it results in a
           non-fast-forward merge in the destination repository.   'git push' is essentially the same as running
           'git merge main' from inside the remote repository.   You should only push to repositories that have
           been created with the --bare flag.  Since pushing messes with the remote branch structure, it’s important
           to never push to another developer’s repository.  But because 'bare' repos do NOT have a working
           directory, it’s impossible to interrupt anybody’s developments.

GIT PULL - It is NOT recommended that you use "git pull" because it can make changes that you don't want.
           Instead, you should use the "git fetch" command followed by the "git merge" command to ensure the
           changes you're making are correct.  As using "git pull" alone may perform a merge that you don't
           want.  To learn more, search the web for:  "git difference between pull and merge"

REMOVE FILE FROM STAGED AREA:  (Seems to do the same thing as "git reset HEAD tom.java" below.)
> git add tom.java
> git rm --cached tom.java  (Removes tom.java from staged area, but doesn't delete the file.)
> del tom.java  (If you want to permanently delete the file.)

REMOVE FILE FROM STAGED AREA:  (Seems to do the same thing as "git rm --cached tom.java" above.)
> git add tom.java
> git reset HEAD tom.java  (Removes tom.java from staged area, but doesn't delete the file.)

DELETE A STAGED FILE:
> git add tom.java
> git rm tom.java

CHANGE ALTERED FILE TO ITS COMMITTED STATE:
Assume the working directory is clean and up to date with the most recent commit,
and you mistakenly do one of the following:
1) Change a file that's previously been committed (in this example blue.html).
2) Change a file that's previously been committed (in this example blue.html), and then "git add" the blue.html file.
To bring back the original blue.html file that's already committed, run the following command:
> git checkout HEAD blue.html

DISPLAY ALL REMOTE REPOSITORIES FROM YOUR CURRENT REPOSITORY.
> git branch -rv   (Displays information similar to the following 3 lines.)
  john-public/pink-page fe17adf Add pink page
  origin/HEAD           -> origin/main
  origin/main         fe17adf Add pink page


RESET TRACKED FILES TO MOST-RECENT COMMIT - Undoes changes to the working directory and the staged snapshot.
                                            Assume you made text changes to an already-committed file named: index.html
                                            To revert your changes made to index.html, do the following:
                                            > git reset --hard
                                            > git clean -f

DELETE ALL UNTRACKED FILES - Assume you created a new file named dummy.html.  But you didn't add or commit it to git, which
                             means dummy.html is NOT tracked.  To remove this dummy.html file AND ALL UNTRACKED FILES, run:
                             > git clean -f  (Remove all untracked files.)

CHANGE MESSAGE OF MOST-RECENT COMMIT:
> git add tom.java
> git commit -m "Commited tom.java file."
> git commit --amend  (Change message in the pop-up editor.)

RENAME A COMMITTED FILE:
> git add tom.java
> git commit -m "Added tom.java file."
> git mv tom.java  jack.java  (Renames tom.java to jack.java)
> git add jack.java
> git commit -m "Added jack.java file."

REMOVE A BRANCH or DELETE A BRANCH:
> git branch -d poop  (Removes the barnch named 'poop')

MERGE A BRANCH
> git checkout main  (Go to the main branch.)
> git merge css  (Merge the css branch into the main branch.)

REMOVE A REMOTE REPOSITORY:
> git remote rm john-public  (Remove the remote repository reference, but the remote repository remains.)

RENAME A REMOTE REPOSITORY:
> git remote rename <old-name> <new-name>

LOG FILE COMMANDS:
> git log --pretty=online
> git log --pretty=format:"%h : %an : %ar : %s"  (Colon chars optional.)
> git log -p -2  (Show last 2 commits.)
> git log --stat
> git log --since=1.weeks  (Shows all changes made in the last 1 week.)
> git log --since="2016-01-20"
> git log --before="2016-01-20"
> git log --author="TJB"

YouTube Git Tutorials --> https://www.youtube.com/watch?v=r63f51ce84A
                      --> https://www.youtube.com/watch?v=HVsySz-h9r4
