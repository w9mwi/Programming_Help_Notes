HTML-CSS3 ON-LINE COURSE
https://www.udemy.com/web-design-for-beginners-real-world-coding-in-html-css/learn/#/
https://www.udemy.com/web-design-for-beginners-real-world-coding-in-html-css/learn/#/

TO PARSE/VALIDATE XML, USE...
http://www.w3schools.com/dom/dom_validate.asp
http://www.w3schools.com/dom/dom_validate.asp
http://www.w3schools.com/dom/dom_validate.asp

=========================================================================================================================
HOW TO SET GIT DEFAULT EDITOR:
> sudo update-alternatives --config editor
Prompts you with the following text to choose a default git editor...

There are 3 choices for the alternative editor (providing /usr/bin/editor).

  Selection    Path               Priority   Status
------------------------------------------------------------
* 0            /bin/nano           40        auto mode
  1            /bin/ed            -100       manual mode
  2            /bin/nano           40        manual mode
  3            /usr/bin/vim.tiny   15        manual mode

Press <enter> to keep the current choice[*], or type selection number: 
=========================================================================================================================


GIT TUTORIALS:  http://rypress.com/tutorials/git/index
                https://git-scm.com/book/en/v2/
                https://www.atlassian.com/git/tutorials/

CREATE GIT REPOSITORY - FROM YOUR COMPUTER VIA THE COMMAND LINE:
                        1) Create a new directory that will hold your new software project.
                        2) From the comand line, run the following:
                           > git init
                           > dir .git   (You should now see a new .git folder that was created.)
                           > git status (You should now see text that reveals the git status.)
DELETE GIT REPOSITORY - FROM YOUR COMPUTER VIA THE COMMAND LINE:
                        Go to the top-level directory/folder of your project (aka, the git repository),
                        then delete the .git folder, which may be invisible.  Doing this deletes the
                        git repository.  You can then delete all other files/folders from this folder
                        to make it completely empty.
                        To delete a specific git branch (in this example, named 'test'), run the following command(s):
                        > git branch -d test  (-d is the delete flag.)
                        ...OR...
                        > git branch -D test  (-D is the delete flag.)
                        NOTE: You cannot delete the 'master' branch using this command.
                              To accomplish that, just delete the .git directory as stated above.
WORKING DIRECTORY - The top-level directory/folder that contains all files and subdirectories
                    that comprise your software project.
SNAPSHOT/STAGING  - A snapshot represents the state of your project at a given point in time.
                    Git’s term for creating a snapshot is called staging because we can add or remove
                    multiple files before actually committing it to the project history.  Staging gives
                    us the opportunity to group related changes into distinct snapshots--a practice that
                    makes it possible to track the meaningful progression of a software project (instead
                    of just arbitrary lines of code).  Only after executing git commit will our snapshot
                    be recorded in the repository. Committed snapshots can be seen as “safe” versions of
                    the project.  Git will never change them, which means you can do almost anything you
                    want to your project without losing those “safe” revisions.
GIT ADD             After a new file (or set of files) is created, and these files contains the correct
                    code, you can add them to your snapshot via the "add" command, like this:
                    > git add index_1.html  index_2.html  index_3.html
                    To add all files (staged that have changes, and unstaged files) in the current directory, run:
                    > git add *
GIT COMMIT          To commit all files of your snapshot (files added with the git "add" command), you can
                    commit them to the repository via the git "commit" command:
                    > git commit -m "Added index.html file."
                    > git status
                    To commit all STAGED files without having to first do a "git add", you can run the following command:
                    > git commit -a -m "Add CSS stylesheet to rainbow.html" (The -a performs the "git add" command on all
                                                                             previously STAGED files.  Which means files
                                                                             that have been previously added with "git add",
                                                                             but have been changed since then.)
                    To add any number of files/directories from your repository,
                    commit that change to the current branch, and push it, do this...
                    First, add the files/directories.
                    > git add .  (Don't forget to type the period . char!)
                    > git commit . -m "Added files/directories."
                    > git push
                    To delete any number of files/directories from your repository,
                    commit that change to the current branch, and push it, do this...
                    First, delete the files/directories.
                    > git commit . -m "Deleted files/directories."
                    > git push
GIT LOG           Run the following:
                  > git log  (Displays only git commits.)
                  > git log --oneline  (Displays each commit on only one line.)
                  > git log --oneline blue.html  (Displays each commit made on the "blue.html" file.)
                  > git log -n 4  (Displays log for the 4 most-recent commits.)
GIT CONFIG        Run the following commands so git knows your name and e-mail address.  You need to
                  do this ONLY ONCE.  Now when you commit files to your git repository, and you
                  later run "git log", your name and e-mail address will show up in the log output.
                  > git config  --global user.name   "Joe Schmoe"
                  > git config  --global user.email  joeschmoe@yahoo.com
GIT CHECKOUT      To checkout an existing branch, do:
                  > git checkout master  (master is name of branch.)
                  To create a new branch named poop, AND checkout this new poop branch simultaneously, run this command:
                  > git checkout -b poop
                  To checkout a previous snapshot, do the following:
                  > git log  (3 lines of text will display, similar to the 3 lines below.)
                    commit c9d66dd85f0b6891e5d3f29fc12750e6ca74ad9d
                    Author: TJB <w9mwi@yahoo.com>
                    Date:   Thu Jan 14 20:22:41 2016 -0600
                  > git checkout c9d66dd85f0b6891e5d3f29fc12750e6ca74ad9d  (Checkout the snapshot shown above.)
                  > git status
                  > git log
                  > git switch -  (This command effectively cancels the above "git checkout c9d66dd85..." command.)
                  > git checkout master  (Returns to the master branch, effectively canceling the above "git checkout c9d66dd85..." command.)
                  > git checkout Version_1.0  (Checks out the "Version 1.0" tag.  For details, read the "TAG A RELEASE" section below.)
TAG A RELEASE     To tag a release, do the following:
                  > git checkout master
                  > git tag -a Version_1.0  -m "Tag Version 1.0"
                  You can now add/commit more files to the "Version 1.0" tag.  When you want to return to the "Version_1.0" tag,
                  run the following command instead of "git checkout c9d66dd8...", which involves the long, cumbersome ID number.
                  > git checkout Version_1.0
GIT REVERT        Undoes a previous commit by applying a new commit.  Undoes changes contained in one of the committed snapshots.
                  > git log
                  > git checkout master  (Choose a snapshot ID from the above "git log" command, and run the following:
                  > git revert b1b4e7a77fe1164952cad7699292024686c3357c  (The changes made in ID "b1b4e7a7..." will be undone.)
GIT RESET         Reset tracked files to match the most recent commit.  Undoes changes to the working directory and the
                  staged snapshot.  Assume you made text changes to an already-committed file named index.html AND you
                  added a brand-new file named dummy.html.  If you decide to scrap those changes (that is, revert your
                  changes made to index.html AND delete the dummy.html file), run the following 2 commands.
                  NOTE: BOTH of the following commands affect the WORKING DIRECTORY.  The "git reset" command also
                        reverts changes made to the STAGED SNAPSHOT, which is made via the "git add" command.
                        The following 2 commands DON'T change the contents of any committed snapshots.
                  > git reset --hard
                  > git clean -f  (Deletes the dummy.html file from the working directory.)
                  The above 2 (TWO) commands together permanently undoes uncommitted changes.
GIT CLEAN         Assume you created a new file named dummy.html.  But you didn't add or commit it to git, which
                  means dummy.html is NOT tracked.  To remove this dummy.html file AND ALL UNTRACKED FILES, run:
                  > git clean -f  (Deletes all untracked files from the working directory.)
BRANCHES         To create a new branch named poop, and then check it out, do the following.  This new poop branch will
                 initially be identical to the branch you currently have checked out.
                 > git branch poop
                 > git checkout poop
                 To create a new branch named poop, AND checkout this new poop branch simultaneously, run this command:
                 > git checkout -b poop

                 In Git, a branch is an independent line of development.  Branches present an error-proof method for
                 incorporating changes from an experiment.  Branches also let you store all of your experiments in a
                 single directory, which makes it much easier to keep track of them and to share them with others.
                 Creating a new branch is really just a way to request an independent working directory, staging
                 snapshot, and history.  There are four (4) core elements to work with throughout the rest of this tutorial:
                 1) The Working Directory
                 2) The Staged Snapshot
                 3) Committed Snapshots
                 4) Development Branches
                 When the "git branch" command creates a new branch, it uses the current HEAD NODE as the starting point
                 for the new branch.  This means the new branch begins as a copy of the existing branch--so it will contain
                 a copy of the existing branch's files located in the current working directory.
                 
                 Git uses the tip of a branch to represent the entire branch.  In other words, a branch is actually
                 a pointer to a single commit—-not a container for a series of commits.

                 The following command displays our one and only branch: * master.  The master branch is Git’s default
                 branch, and the asterisk next to it tells us that it’s currently checked out.  Notice that since
                 there’s only one working directory for each project, only one branch can be checked out at a time.
                 > git branch
                 * master  (This gets displayed when "git branch" is run.)
                 Next, check out a previous snapshot (514fbe7 referes to the ID of the crazy.html commit.)
                 > git checkout 514fbe7
                 From this, let's now create a new branch called "crazy":
                 > git branch crazy
                 And now, let's checkout this new "crazy" branch so we'll no longer be on the "master" branch.
                 > git checkout crazy
                 The new "crazy" branch is a completely isolated from the "master" branch, so we can
                 mess with files in this same working directory without changing any files on the "master" branch.

                 Rename crazy.html to rainbow.html, then use the following Git commands to update the repository.
                 > git status
                 > git rm crazy.html
                 > git status
                 > git add rainbow.html
                 > git status
                 > git commit -m "Rename crazy.html to rainbow.html"
                 The git rm command above tells Git to stop tracking crazy.html (and delete it if necessary), and the
                 git add command above starts tracking rainbow.html.  The renamed: crazy.html -> rainbow.html message
                 in the "git status" output shows us that Git is smart enough to figure out when we’re renaming a file.
                 Now, when we run "git branch", we see both branches (crazy and master) that exist:
                 > git branch
                     crazy
                   * master

DELETE BRANCH   To delete a branch named poop, run the following commands.  Git will warn you if you’re deleting an
                unmerged branch.
                > git branch -d poop  (-d is the delete flag.  Use -D flag if the poop branch hasn't been merged into
                                          another branch.)
                > git branch  (Confirm the poop branch is gone.)

GIT MERGE       > git checkout master  (Go to the master branch.)
                > git merge css  (Merge the css branch into the master branch.)

                Git can merge changes into any branch (not just the master branch).  We can pull the updates in with
                with the familiar git merge command.  Merging only affects the checked-out branch.  Now, merge the
                master branch into the crazy branch...
                > git checkout crazy
                > git merge master
                > git log --oneline
GIT REBASE     On the this web page (http://rypress.com/tutorials/git/rebasing), search for this text: Publish News Hotfix
               Under that text you'll see a diagram labeled with this text:  Fast-forwarding master to the news-hotfix
               We'll call this the BEFORE DIAGRAM.
               Below that diagram, you'll see another diagram labeled with this text:  Rebasing the about branch onto master
               We'll call this the AFTER DIAGRAM.
               Using the git rebase command, we want to change the 'about' branch represented in the BEFORE DIAGRAM,
               to the 'about' branch represented in the AFTER DIAGRAM.  To do this, run the following 2 commands:
               > git checkout about
               > git rebase master
               NOTE: Git rebase requires you to be on the branch that you want to alter.  In this example,
                     we must be on the 'about' branch.  Running the 'git rebase master' command will alter
                     the 'about' branch so its TAIL NODE will now connenct to the HEAD NODE of the 'master' branch.
                     Again, see the BEFORE DIAGRAM versus the AFTER DIAGRAM on the web page mentioned above.

              An INTERACTIVE REBASE prompts the user with an opened text file, which can be edited to alter how the
              rebase performs.  If the user does NOT alter this text file, the rebase that occurs will be identical
              to running the 'git rebase' command WITHOUT the -i flag shown below.  To run an interactive rebase on
              the 'about' branch, do the following:
              > git checkout about
              > git rebase -i master  (The -i flag menas INTERACTIVE, so the user will be prompted to change behavior.)
              
              If you're in the middle of performing a rebase, and you get lost (not certain if what you're doing
              is correct), you can abort rebase in midstream by running the following command:
              > git rebase ‑‑abort

              Rebasing enables fast-forward merges by moving a branch to the tip of another branch.  It effectively
              eliminates the need for merge commits, resulting in a completely linear history.  To an outside observer,
              it will seem as though you created every part of your project in a neatly planned sequence, even though
              you may have explored various alternatives or developed unrelated features in parallel.  Rebasing gives
              you the power to choose exactly what gets stored in your repositories.

GIT REFLOG    Git uses something called the reflog to record every change you make to your repository.  The reflog is
              a chronological listing of repository history, without regard for the repository’s branch structure.
              This lets us find dangling commits that would otherwise be lost from the project history.  Run the
              following command, which will display a list of history:
              > git reflog

REMOTE REPOSITORIES  A remote repository is one that's not your own.  It can be another Git repository located
                     on your company’s network, the internet, or even on your own hard disk.  Remote branches
                     act just like local branches, except they represent a branch located in someone else’s repository.
                     Think of REMOTE BRANCHES AS READ-ONLY BRANCHES.   If you approve the changes a remote branch contains,
                     you can merge it into a local branch with a normal git merge. 

CLONING REPOSITORY  To clone an existing repository located on your hard disk, do the following...
                    On the command line, navigate to the PARENT DIRECTORY containing the repository
                    you want to clone.  In this example, the "C:\Tom\Programming" parent directory
                    contains the child directory "C:\Tom\Programming\my-git-repo".  So navigate to
                    the "C:\Tom\Programming" directory, then run the following commands:
                       > git clone my-git-repo  marys-repo  (The my-git-repo directory/repository gets cloned into the
                                                             marys-repo directory/repository.  This command also creates
                                                             the marys-repo directory.)
                       > cd marys-repo  (You are now in the newly-created repository directory named marys-repo.)
                       > git branch -rv (Verify that the only the LOCAL BRANCH existing in marys-repo is the 'master'
                                         branch.)
                       > git remote -v  (Verify the marys-repo BRANCH does have a REMOTE REPOSITORY named 'origin'.  This
                                        REMOTE REPOSITORY named 'origin' was created via the above "git clone" command.)
                       > git config user.name "Mary"
                       > git config user.email w9mwi@yahoo.com
                    When you clone a repository, Git automatically adds an 'origin' REMOTE REPOSITORY to the newly-cloned
                    repository.

                    Next, navigate back to the "C:\Tom\Programming\my-git-repo" directory, and run the following commands:
                       > git remote -v (Notice that there exists no remote repository.)
                       > git remote add mary ../marys-repo   (Create a remote repository named 'mary', pointing to the
                                                              repository located in "C:\Tom\Programming\marys-repo")
                       > git remote -v  (The following 2 lines are output.)
                       mary    ../marys-repo (fetch)
                       mary    ../marys-repo (push)
                    IMPORTANT: From the "C:\Tom\Programming\marys-repo" directory, we can now reference the 'origin'
                               repository.
                    IMPORTANT: From the "C:\Tom\Programming\my-git-repo" directory, we can now reference the 'mary'
                               repository.

MERGING FROM ONE REPOSITORY INTO ANOTHER:
                    After you've completed all steps in the above CLONING REPOSITORY section, do the following
                    to merge code from the 'mary' repository (located in the 'marys-repo' directory) into the
                    'origin' repository (located in the 'my-git-repo' directory).
                    From the "C:\Tom\Programming\my-git-repo" directory, run these commands:
                       > git fetch mary  (Fetch all of the branches located in the marys-repo repository into
                                          the my-git-repo repository.)
                       > git branch -rv  (Displays all branches that exist in REMOTE REPOSITORIES, like the following
                                          2 lines.)
                         mary/bio-page
                         mary/master
                   Let's now checkout the mary/master branch (displayed immediately above) into the my-git-repo directory.
                       > git checkout mary/master  (Checkout the master branch from the mary repository,
                                                    so we can review code changes made by Mary.)
                       > git checkout master       (Checkout our own master branch, which overwrites the mary/master
                                                    branch that we just checked out in the previous command.)
                       > git merge mary/master     (Merge the mary/master branch into our master branch.)
FETCH AND PUSH    The fetch and push commands are almost opposites.  Fetch IMPORTS A BRANCH from a remote repository.
                  Push CREATES A NEW LOCAL BRANCH in a remote repository.  Navigate to the "C:\Tom\Programming\my-git-repo"
                  directory, and run the following 2 commands.
                  > git branch dummy     (Creates a new 'dummy' branch in the my-git-repo directory.)
                  > git push mary dummy  (Export the 'dummy' branch to the 'mary' repository.)
                  As a general rule, you should never push into another developer’s repository.  The reason "git push" exists
                  is that it allows you to make changes to a PUBLIC repository, that should be maintained by multiple people.
                  Next, navigate to the "C:\Tom\Programming\my-git-repo" directory, tag the master branch in this
                  directory, and then push this tagged v2.0 version to the 'mary' repository.
                  > git tag -a v2.0 -m "An even stabler version of the website"
                  > git push mary v2.0
                  Navigate to the "C:\Tom\Programming\marys-repo" directory, and run the following command.
                  > git tag  (The 'v2.0' tag should display.)
                  It’s very easy to forget to push new tags, so if it seems like your project has lost a tag or two,
                  it’s most likely because you didn’t to push them to the remote repository.
                  Note that "remotes" are for people.  "Branches" are for topics.  Do not create separate branches
                  for each of your developers—-give them separate repositories and bookmark them with git remote add.
                  Branches should always be for project development, not user management.  The 'git push' command works
                  ONLY if you cloned from a server to which you have write access, AND IF nobody has pushed in the
                  meantime.  If you and someone else clone at the same time, and they push upstream, and then later you
                  push upstream, your push will rightly be rejected.  You’ll have to pull down their work first and
                  incorporate it into yours before you’ll be allowed to push.

GIT FETCH         Since fetched content is represented as a remote branch, it has absolutely no effect on your local
                  development work. This makes fetching a safe way to review commits before integrating them with your
                  local repository. It’s similar to svn update in that it lets you see how the central history has
                  progressed, but it doesn’t force you to actually merge the changes into your repository.

                  SUMMARY...
                  > git clone <remote-path>  (Create a copy of a remote Git repository.)
                  > git remote -v  (List remote repositories.)
                  > git remote add <remote-name> <remote-path>  (Add a remote repository.)
                  > git remote show origin  (Show details about the remote branch named 'origin'.)
                  > git fetch <remote-name>  (Download remote branch information, but do not merge anything.)
                  > git merge <remote-name>/<branch-name>  (Merge a remote branch into the checked-out branch.)
                  > git branch -rv  (List remote branches.)
                  > git push <remote-name> <branch-name>  (Push a local branch to another repository.)
                  > git push <remote-name> <tag-name>     (Push a tag to another repository.)
CENTRALIZED WORKFLOWS
                  Running the below "git init" command creates a new repository directory named central-repo.git.  The
                  --bare flag indicates there will NOT be a working directory created for this repository.  If you navigate
                  to the C:\Tom\Programming\central-repo.git directory, you'll see it does NOT contain the standard
                  .git directory.  As a matter of fact, the files contained in this C:\Tom\Programming\central-repo.git
                  directory contain the same files that exist in the standard .git directory.  (That's why we this
                  directory name contains the ".git" extension.)  Not having a working directory prevents anyone
                  from developing in the central repository, which eliminates the possibility of messing up another
                  user’s environment with git push.  A central repository should act only as a storage facility--not
                  as a development environment.
                  > git init --bare central-repo.git
                  Add this new central repository (central-repo.git) as a REMOTE REPOSITORY to both the 'marys-repo' and
                  the 'my-git-repo' repositories by running the following commands:
                  > cd marys-repo  (Navigate to the C:\Tom\Programming\marys-repo directory).
                  > git remote rm origin  (Delete the existing remote repository named 'origin'.)
                  > git remote add origin ../central-repo.git  ('marys-repo' now references central-repo.git as 'origin'.)
                  > cd my-git-repo  (Navigate to the C:\Tom\Programming\my-git-repo directory).
                  > git remote add origin ../central-repo.git  ('my-git-repo' now references central-repo.git as 'origin'.)
                  > git remote rm mary  (Remove the existing 'mary' remote epository from my-git-repo.)
                  Now, push the master branch of the my-git-repo repository to the central-repo.git repository.
                  > cd C:\Tom\Programming\my-git-repo
                  > git push origin master  (The central-repo.git master branch gets a copy of the my-git-repo master
                                             branch.)
                  > cd C:\Tom\Programming\central-repo.git
                  > git log  (Confirm that the output of this log is identical to the log output on the my-git-repo
                              repository.
                  NOTE: The "git push" command creates a local branch in the destination repository.  It's dangerous to
                        push to a friend’s repository, as she probably won’t appreciate other programmers creating new
                        branches in her working directory without her consent.   However, it’s safe to create local
                        branches in central-repo.git because it has no working directory, which means it’s impossible
                        to disturb anyone’s development.
                  WARNING:  NEVER rebase commits that have been pushed to a shared repository.  If you need to change
                            a public commit, use the "git revert" command discussed previously.
DISTRIBUTED WORKFLOWS
                  Run the following commands:
                  > cd C:\Tom\Programming\my-git-repo
                  > git remote rm  origin  (Delete the existing remote 'origin' branch from the my-git-repo directory.)
                  > git remote add origin https://github.com/w9mwi/my-git-repo.git  (Point the remote 'origin' repository
                                                                                     to GitHub.)
                  > git push origin master  (Push my-git-repo's master branch to the remote 'origin' (GitHub) branch.
                  Create a repository for co-worker John:
                  > cd C:\Tom\Programming
                  > git clone  https://github.com/w9mwi/my-git-repo.git  johns-repo  (johns-repo will contain our
                                                                                      GitHub contents.)
                  > cd johns-repo
                  > git config user.name "John"
                  > git config user.email junk@shit.com
                  > git checkout -b pink-page  (Creates a new branch named pink-page, and then does a checkout on pink-page.)
                  Add a new repository to GitHub named 'johns-repo' via the GitHub web site.  Next, on your hard disk, inside
                  the C:\Tom\Programming\johns-repo directory, run the following command to create a new remote repository
                  named 'john-public', which will point to the new 'johns-repo' repository on GitHub.
                  > git remote add  john-public  https://github.com/w9mwi/johns-repo.git
                  From the C:\Tom\Programming\johns-repo directory, make certain you have the 'pink-page' branch checked out.
                  Then, push the pink-page local branch to the 'john-public' remote branch that's located on GitHub...
                  > cd C:\Tom\Programming\johns-repo
                  > git checkout pink-page
                  > git push john-public pink-page  (Creates new 'pink-page' repository from GitHub in
                                                     C:\Tom\Programming\johns-repo)
                  In the my-git-info directory, add a new remote repository named 'john' that points to 'johns-repo'
                  in GitHub...
                  > cd C:\Tom\Programming\my-git-repo
                  > git remote add john  https://github.com/w9mwi/johns-repo.git
                  > git fetch john  (Copies contents of GitHub's 'johns-repo' repository to the new 'john' repository.)
                  > git branch -rv  (Shows the new john/pink-page remote repository.)
                  > git checkout john/pink-page  (Checkout the 'pink-page' repository located in
                                                  C:\Tom\Programming\johns-repo)
                  If you approve John's updates, merge them into your master branch (in the my-git-repo directory).
                  > git checkout master
                  > git merge john/pink-page
                  Finally, push your master branch to the 'origin' GitHub 'my-git-repo' repository, which corresponds
                  to your 'my-git-repo' working directory.
                  > git push origin master
                  Do the following on the 'marys-repo' branch.
                  > cd C:\Tom\Programming\marys-repo
                  > git remote rm origin  (Delete the previous 'origin' branch, as we make a new one that points to GitHub.)
                  > git remote add origin  https://github.com/w9mwi/my-git-repo.git  (Creates new 'origin' branch pointing
                                                                                      to GitHub.)
                  > git checkout master
                  > git fetch origin  (Copies contents of GitHub's 'my-git-repo' repository to the new 'origin' repository.)
                  > git rebase origin/master
                  Update johns-repo on your hard disk, similar to what we did with marys-repo above.
                  > cd C:\Tom\Programming\johns-repo
                  > git checkout master
                  > git fetch origin
                  > git rebase origin/master

PATCH WORKFLOWS  Add a remote branch named 'origin' to BOTH the my-git-repo and the marys-repo repositories.
                 Both these remote branches named 'origin' will point to the same remote repository.
                 > cd C:\Tom\Programming\my-git-repo
                 > git remote add origin https://github.com/w9mwi/my-git-repo.git
                 > cd C:\Tom\Programming\marys-repo
                 > git remote add origin https://github.com/w9mwi/my-git-repo.git

TIPS AND TRICKS
                 Archive the 'master' repository in the 'my-git-repo' directory (not including the .git directory).
                 Removing the .git directory removes all version control information, and you’re left with a single
                 snapshot of your project.
                 > cd C:\Tom\Programming\my-git-repo
                 > git archive master --format=zip --output=../website-12-10-2012.zip  (On Windows)
                 > git archive master --format=tar --output=../website-12-10-2012.tar  (On UNIX)
                 You can also bundle a repository, which is similar to the above 'archive' command, except the resulting
                 file does contain the .git directory (versioning information of the entire project).  In this example,
                 we bundle the 'master' branch of the 'my-git-repo' directory.
                 > git bundle create ../repo.bundle master  (Saves 'master' branch of the repository to the repo.bundle
                                                             file.)
                 Navigate to the directory containing the repo.bundle file created in the above command, and run the
                 following:
                 > git clone repo.bundle repo-copy -b master  (Creates a cloned repository in a child directory named
                                                               'repo-copy'.)
                 Use the bundle command above to backup an entire Git repository.
                 MAKE GIT IGNORE FILES
                 To make Git ignore certain files, you can do the following:
                 > notepad junkfile.txt  (Create a new file called 'junkfile.txt' and save it in the 'my-git-repo' directory.)
                 > git status  (Notice the junkfile.txt appears as an untracked file.)
                 In the same 'my-git-repo' directory, create a new file called .gitignore and enter this text into it:
                 junkfile.txt
                 > git status (junkfile.txt no longer appears as an untracked file, but the .gitignore file does!
                               Fix that here...)
                 > git add .gitignore
                 > git commit -m "Add .gitignore file"
                 > git status  (Notice there are no more untracked files.)
                 
                 

PLUMBING
                  Running the following command will output the complete representation of a commit, which consists of:
                  Tree + Parent + User Data + Commit Message
                  > git cat-file commit HEAD
                  A tree object is Git’s representation of the “snapshots”. A snapshot records the state of a directory
                  at a given point, without any notion of time or author.  To tie trees together into a coherent project
                  history, Git wraps each one in a commit object and specifies a parent, which is just another commit.
                  By following the parent of each commit, you can walk through the entire history of a project.
                  Run the below commands
                  > git log --oneline  (Obtain an ID number used by the following comand.)
                  > git cat-file tree 781e5cd  (Notice output contains ugly binary cruft.)
                  > git ls-tree 781e5cd        (Output looks much cleaner than above command.)
                  Regarding the output of the above 2 commands: a 'blob' represents a file, a 'tree' represent a folder.
                  Since a blob represents a file, obtain an ID number from the following command that represents a blob.
                  > git cat-file blob 3c13974  (Obtain a an ID from one of the blob files that display.)
                  > git cat-file blob 30560188ea822a5c0fe050eccac16d8ffe47e470  (Prints file contents.)
                  IMPORTANT: A detached HEAD state occurrs when HEAD doesn't coincide with the tip of any branch.
                  Run the following to see this...
                  > git checkout HEAD~1
                  > git status  (You should see a message siminar to this:  HEAD detached at 1287d48)
                  > git checkout master
                  > git status  (The 'HEAD detached' message above should now be gone.)
HOOKS             Read section titled 'Hook into Git’s Internals' on this web page:
                  http://rypress.com/tutorials/git/tips-and-tricks
                  Navigate to the ./git/hooks directory in your repository folder.  You will notice about 9 file names that
                  end with the .sample extension.  These are shell script files.  When the '.sample' extension is removed
                  from these file names, these files will execute the shell script contents of these files.
VIEW DIFFS BETWEEN COMMITS
                  The git diff command is incredibly useful for pinpointing contributions from other developers.  EXAMPLES:
                  > git diff  (Generates a detailed view of all uncommitted changes.)
                  > git diff --cached  (The --cached flag generates a diff between the staged snapshot and most-recent
                                        commit.)
                  > git diff HEAD~2..HEAD~1
                  > git diff master..john/pink-page

========================================================================================================================
========================================================================================================================
HOW TO PUSH YOUR LOCAL HARD DISK REPOSITORY FILES TO A REMOTE GITHUB REPOSITORY
-------------------------------------------------------------------------------

1) Create a new repository on GitHub named tomsJunkRepo, and leave it empty.
2) Run the following:
   > cd C:\Tom\Programming  (The local hard disk directory that will contain your new local repository.)
   > mkdir tomsJunkRepo
3) In the tomsJunkRepo directory, create the .gitignore file, create some other files, and create some files in a
   child directory.  Then create a new 'master' branch in your local repository by running the following commands:
   > cd C:\Tom\Programming\tomsJunkRepo
   > git init  (Creates your local Git repository.)
   > git status (Confirm your local repository was created.)
   > git add .  ...OR...   > git add *   (Adds all untracked files to staging area.)
   > git status (Confirm your files and child directories were added/staged.)
   > git branch -v (Confirm there does NOT yet exist a local branch.)
   > git commit -m "Initial commit."
   > git status  (Confirm the above 'git commit' command has created a branch named 'master'.)
   > git branch -v  (Confirm you're now on this 'master' branch.)
4) Create a new remote repository named 'origin', which will point to your GitHub repository designated by the URL below.
   > git remote -v  (Confirm that there does NOT yet exist any remote repositories.)
   > git remote add origin  https://github.com/w9mwi/tomsJunkRepo.git  (VIA URL, adds a new remote repository named
                                                                        'origin'.)
   > ...OR...
   > git remote add origin  git@github.com:w9mwi/tomsJunkRepo.git  (VIA SSH, adds a new remote repository named 'origin'.
                                                                    Generate new SSH key:
                                                                    https://help.github.com/articles/generating-a-new-ssh-key)
   > git remote -v  (Confirm there now exists a remote repository named 'origin'.)
5) Look at the contents of the 'tomsJunkRepo' repository on your github.com web page, and notice it does NOT contain
   any of the files/directories contained in your local 'tomsJunkRepo' repository.
6) Push the contents of your local 'tomsJunkRepo' repository to the GitHub web site by running the following commands:
   > git branch -rv (Confirm there does NOT yet exist any remote branches--even though the 'origin' remote repository
                     does exist.)
   > git push origin master  (Push the contents of your local 'master' branch to the 'origin' remote repository.)
   > git branch -rv  (Confirm that there now exists a REMOTE repository/branch named origin/master.)
   > git remote show origin  (Prints details about the remote 'origin' repository, similar to the following 8 lines of text.)
     * remote origin
       Fetch URL: https://github.com/w9mwi/tomsJunkRepo.git
       Push  URL: https://github.com/w9mwi/tomsJunkRepo.git
       HEAD branch: master
       Remote branch:
         master tracked
       Local ref configured for 'git push':
         master pushes to master (local out of date)
7) Look at the contents of the 'tomsJunkRepo' repository on your github.com web page, and notice it now DOES CONTAIN
   the files/directories contained in your local 'tomsJunkRepo' repository.
8) THE END - Your local 'master' branch has successfuly been pushed to the 'master' branch of the REMOTE repository
             named 'origin'.

HOW TO FETCH+MERGE FILES CHANGES MADE ON GITHUB TO YOUR LOCAL 'MASTER' BRANCH
-----------------------------------------------------------------------------
1) Change some text in your files on GitHub.  We'll now fetch+merge these GitHub files to the corresponding files
   on your local 'master' branch.
> git checkout master  (Make certain you're on the local 'master' branch.)
> git remote show origin  (Show details about the remote 'origin' repository.)
> git fetch origin     (Import file changes made on 'origin' remote repo. to your local 'master' branch.
                        NOW DO A GIT MERGE...)
> git merge origin/master  (Only after you run this command will you notice that your files on the local 'master' branch
                            now reflect the files located on GitHub.)
2) THE END - File changes made on the GitHub web site have now been fetched+merged into your local 'master' branch.



HOW TO PUSH FILE CHANGES MADE ON YOUR LOCAL 'MASTER' BRANCH TO THE GITHUB WEB PAGE.)
------------------------------------------------------------------------------------
> checkout master  (Make certain you're on the local 'master' branch.)
1) Change content of some files on your local 'master' branch, then run the following commands:
   > git status  (Shows the files that you changed.)
   > git add .  (Stage the changed files.)
   > git commit -m "Modified the 4 text files."
   > git status  (Verify all the repository is "clean", which means all files have been committed.)
   > git push origin master
2) Verify that all files changed on your local 'master' branch have been pushed to the GitHub web page.
3) THE END

========================================================================================================================
========================================================================================================================



========================================================================================================================
========================================================================================================================
GIT COMMANDS - GIT COMMANDS - GIT COMMANDS - GIT COMMANDS - GIT COMMANDS - GIT COMMANDS

An UNTRACKED FILE is a file that's never had the "git add" command run on it.
A TRACKED FILE is a file that has had the "git add" command run on it at least one time.
A STAGED FILE is a file that has NOT been altered/changed since it was last committed via the "git commit" command.
Every time you make a change to a STAGED FILE, you must again run the "git add" command on it before it can
be committed via the "git commit" command.

GIT CHECKOUT BRANCHES
> git checkout master  (The repository points to the 'master' branch.)
> git checkout poop    (The repository points to the 'poop' branch.)
> git log --oneline  (Prints something similar to below text.)
  6715fc5 Added whitespace to blue.html file.
  430d978 Add .gitignore file
  49f80f3 Changed index.html, added news4.html.
  fe17adf Add pink page
  1287d48 Add CSS styles for headings and links
> git checkout 49f80f3  (This makes your working directory match the exact state of the 49f80f3 commit.  HEAD no longer
                         points to a branch, but to a previous commit deignated by the 49f80f3 ID.  This is called a
                         “detached HEAD” state.)
> git checkout 6715fc5 blue.html  (Checks out the blue.html file that was in the 6715fc5 commit.  This can change the
                                   current state of your project.  You can add + commit this olded blue.html file,
                                   or run the following command to revert that file back to its current state.)
> git checkout HEAD blue.html     (Returns contents of blue.html file to the one in the most-recent commit.)


GIT CHECKOUT A FILE
> git checkout fe17adf hello.py

GIT PUSH - The most common use case for git push is to publish your local changes to a central repository.  After you’ve
           accumulated several local commits and are ready to share them with the rest of the team, you (optionally)
           clean them up with an interactive rebase, then push them to the central repository.
           'git push' is how you transfer commits from your local repository to a remote repo.  It's the counterpart
           to git fetch.  But whereas 'GIT FETCH' IMPORTS COMMITS TO LOCAL BRANCHES, 'GIT PUSH' EXPORTS COMMITS TO
           REMOTE BRANCHES.  'GIT PUSH' HAS THE POTENTIAL TO OVERWRITE CHANGES, so you need to be careful how you
           use it.  To prevent you from overwriting commits, Git won’t let you push when it results in a
           non-fast-forward merge in the destination repository.   'git push' is essentially the same as running
           'git merge master' from inside the remote repository.   You should only push to repositories that have
           been created with the --bare flag.  Since pushing messes with the remote branch structure, it’s important
           to never push to another developer’s repository.  But because 'bare' repos do NOT have a working
           directory, it’s impossible to interrupt anybody’s developments.

GIT PULL - Merging upstream changes into your local repository is a common task in Git-based collaboration workflows.
           We know how to do this with git fetch followed by git merge.  'GIT PULL' COMBINES 'GIT FETCH' + 'GIT MERGE'
           INTO A SINGLE COMMAND.  'git pull' is analagous to and SVN UPDATE. It’s an easy way to synchronize your local
           repository with upstream changes.

REMOVE FILE FROM STAGED AREA:  (Seems to do the same thing as "git reset HEAD tom.java" below.)
> git add tom.java
> git rm --cached tom.java  (Removes tom.java from staged area, but doesn't delete the file.)
> del tom.java  (If you want to permanently delete the file.)

REMOVE FILE FROM STAGED AREA:  (Seems to do the same thing as "git rm --cached tom.java" above.)
> git add tom.java
> git reset HEAD tom.java  (Removes tom.java from staged area, but doesn't delete the file.)

DELETE A STAGED FILE:
> git add tom.java
> git rm tom.java

CHANGE ALTERED FILE TO ITS COMMITTED STATE:
Assume the working directory is clean and up to date with the most recent commit,
and you mistakenly do one of the following:
1) Change a file that's previously been committed (in this example blue.html).
2) Change a file that's previously been committed (in this example blue.html), and then "git add" the blue.html file.
To bring back the original blue.html file that's already committed, run the following command:
> git checkout HEAD blue.html

DISPLAY ALL REMOTE REPOSITORIES FROM YOUR CURRENT REPOSITORY.
> git branch -rv   (Displays information similar to the following 3 lines.)
  john-public/pink-page fe17adf Add pink page
  origin/HEAD           -> origin/master
  origin/master         fe17adf Add pink page


RESET TRACKED FILES TO MOST-RECENT COMMIT - Undoes changes to the working directory and the staged snapshot.
                                            Assume you made text changes to an already-committed file named: index.html
                                            To revert your changes made to index.html, do the following:
                                            > git reset --hard
                                            > git clean -f

DELETE ALL UNTRACKED FILES - Assume you created a new file named dummy.html.  But you didn't add or commit it to git, which
                             means dummy.html is NOT tracked.  To remove this dummy.html file AND ALL UNTRACKED FILES, run:
                             > git clean -f  (Remove all untracked files.)

CHANGE MESSAGE OF MOST-RECENT COMMIT:
> git add tom.java
> git commit -m "Commited tom.java file."
> git commit --amend  (Change message in the pop-up editor.)

RENAME A COMMITTED FILE:
> git add tom.java
> git commit -m "Commited tom.java file."
> git mv tom.java  rosemary.java  (Renames tom.java to rosemary.java)

REMOVE A BRANCH:
> git branch -d poop  (Removes the brnch named 'poop')

MERGE A BRANCH
> git checkout master  (Go to the master branch.)
> git merge css  (Merge the css branch into the master branch.)

REMOVE A REMOTE REPOSITORY:
> git remote rm john-public  (Remove the remote repository reference, but the remote repository remains.)

RENAME A REMOTE REPOSITORY:
> git remote rename <old-name> <new-name>

LOG FILE COMMANDS:
> git log --pretty=online
> git log --pretty=format:"%h : %an : %ar : %s"  (Colon chars optional.)
> git log -p -2  (Show last 2 commits.)
> git log --stat
> git log --since=1.weeks  (Shows all changes made in the last 1 week.)
> git log --since="2016-01-20"
> git log --before="2016-01-20"
> git log --author="TJB"

YouTube Git Tutorials --> https://www.youtube.com/watch?v=r63f51ce84A
                      --> https://www.youtube.com/watch?v=HVsySz-h9r4
