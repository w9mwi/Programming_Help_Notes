HTML-CSS3 ON-LINE COURSE
https://www.udemy.com/web-design-for-beginners-real-world-coding-in-html-css/learn/#/
https://www.udemy.com/web-design-for-beginners-real-world-coding-in-html-css/learn/#/

TO PARSE/VALIDATE XML, USE...
http://www.w3schools.com/dom/dom_validate.asp
http://www.w3schools.com/dom/dom_validate.asp
http://www.w3schools.com/dom/dom_validate.asp

===================================================================================================
HOW TO SET GIT DEFAULT EDITOR:

> sudo update-alternatives --config editor
Prompts you with the following text to choose a default git editor...

The asterisk (*) designates the editor that git currently uses.
To keep the current git editor, just press the <enter> key.
To change the git editor, type the number shown in the 'Selection' column.

  Selection    Path               Priority   Status
------------------------------------------------------------
* 0            /bin/nano           40        auto mode
  1            /bin/ed            -100       manual mode
  2            /bin/nano           40        manual mode
  3            /usr/bin/vim.tiny   15        manual mode

If the editor you want isn't in the above list (for example, the "gedit"
editor), you can change git default editor to "gedit" by adding the below
text to the ~/.bashrc file.  (This has been confirmed to work.)
export GIT_EDITOR=gedit

===================================================================================================

GIT TUTORIALS:  https://git-scm.com/book/en/v2/
                https://www.atlassian.com/git/tutorials/

CREATE GIT REPOSITORY - FROM YOUR COMPUTER VIA THE COMMAND LINE:
                        1) First, create a new directory/folfder  that will hold your new software project,
                           then navigate to that newly-created directory.
                        2) From the comand line, run the following:
                           > git init
                           > dir .git   (You should now see a new .git folder that was created.)
                           > git status (You should now see text that reveals the git status.)
                           > git branch css    (Names your newly-created git repository as the "css" branch)
                           > git checkout css  (This command puts you into the newly-created "css" branch to begin your work.)

DELETE GIT REPOSITORY - FROM YOUR COMPUTER VIA THE COMMAND LINE:
                        Go to the top-level directory/folder of your project (aka, the git repository),
                        then delete the .git folder, which may be invisible.  Doing this deletes the
                        git repository.  You can then delete all other files/folders from this folder
                        to make it completely empty.
                        To delete a specific git branch (in this example, named 'test'), run the following command(s):
                        > git branch -d test  (-d deletes the branch ONLY if the branch is fully merged.)
                        ...OR...
                        > git branch -D test  (-D deletes the branch regardless if the branch is unmerged or fully merged.)
                        NOTE: You cannot delete the 'main' branch using this command.
                              To delete the 'main' branch, just delete the repository's .git directory.
WORKING DIRECTORY - The top-level directory/folder that contains all files and subdirectories
                    that comprise your software project.
SNAPSHOT/STAGING  - A snapshot represents the state of your project at a given point in time.
                    Git’s term for creating a snapshot is called staging because we can add or remove
                    multiple files before actually committing it to the project history.  Staging gives
                    us the opportunity to group related changes into distinct snapshots--a practice that
                    makes it possible to track the meaningful progression of a software project (instead
                    of just arbitrary lines of code).  Only after executing git commit will our snapshot
                    be recorded in the repository. Committed snapshots can be seen as “safe” versions of
                    the project.  Git will never change them, which means you can do almost anything you
                    want to your project without losing those “safe” revisions.

GIT STATUS          Displays the current status of your local git repository.  EVERY TIME YOU MAKE A
                    CHANGE WITH ANY GIT COMMAND, it's a good idea to run "git status".  This will confirm
                    that the change you made actually  occurred.  Better yet, if you made a mistake with
                    your most-recent git command, "git status" will likely tell you how to undo that change!
                    > git status

GIT ADD             After a new file (or set of files) is created, and these files contains the correct
                    code, you can add them to your snapshot via the "add" command, like this:
                    > git add index_1.html  index_2.html  index_3.html
                    To add all files in the current directory (both staged files that have changes,
                    and unstaged files) , run this command:
                    > git add *

GIT COMMIT          To commit all files of your snapshot (files added with the git "add" command), you can
                    commit them to the repository via the git "commit" command:
                    > git commit -m "Added index.html file."
                    > git status
                    To commit all STAGED files without having to first do a "git add", you can run the following command:
                    > git commit -a -m "Add CSS stylesheet to rainbow.html" (The -a performs the "git add" command on all
                                                                             previously STAGED files.  Which means files
                                                                             that have been previously added with "git add",
                                                                             but have been changed since then.)
                    The following commands will add any number of files/directories from
                    your repository, then commit them to the current branch.  After you
                    add and commit, run "git push" to put them in the remote repository.
                    First, add the files/directories.
                    > git add .  (Don't forget to type the period . char!)
                    > git commit . -m "Added files/directories."
                    > git push
                    To delete any number of files/directories from your repository,
                    commit that change to the current branch, and push it, do this...
                    First, delete the files/directories.
                    > git commit . -m "Deleted files/directories."
                    > git push

                    If you made a mistake with your most-recent commit (the last commit you made),
                    you can undo your previous commit by first making the fix, and then running the
                    "git commit --amend" command.  Running "git commit --amend" will do the
                    following, in this order.
                       1) undo the previous commit, in which you made a mistake.
                       2) pick up the change(s) you made since the previous commit.
                       3) performs the commit that includes your most recent change(s).
                       EXAMPLE: Assume you performed a "git commit", but you forgot to first run
                                "git add" on 1 of 3 files you wanted to be part of that commit.
                                You would fix that by doing the following.
                    > git add file_1
                    > git add file_2   (You forgot to run "git add file_3")
                    > git commit -m "committed file_1 and file_2."
                    > git add file_3
                    > git commit --amend  (Now, all 3 of your files have been added and committed.

                    If your most-recent commit is all OK, and you run "git commit --amend", it will
                    do nothing except launch the git editor, allowing you to change your git commit
                    message.

GIT FETCH         Use the "git "fetch" command, followed by the "git merge" command, in place of the
                  "git pull" command.
                  > git fetch
                  > git merge

GIT LOG           Run the following:
                  > git log  (Displays only git commits.)
                  > git log --oneline  (Displays each commit on only one line.)
                  > git log --oneline blue.html  (Displays each commit made on the "blue.html" file.)
                  > git log -n 4  (Displays log for the 4 most-recent commits.)

GIT CONFIG        Run the following commands so git knows your name and e-mail address.  You need to
                  do this ONLY ONCE.  Now when you commit files to your git repository, and you
                  later run "git log", your name and e-mail address will show up in the log output.
                  > git config  --global user.name   "Joe Schmoe"
                  > git config  --global user.email  joeschmoe@yahoo.com

                  To display the current git config settings run the following commands:
                  > git config --list
                  > git config --list --show-origin

GIT CHECKOUT      Checks out an existing branch.  So in the working directory, before you do a checkout, you must first
                  create a new branch by running "git checkout" similar to this example:  git branch name_of_new_branch

                  > git checkout main  (main is name of branch.)
                  To create a new branch named poop, AND checkout this new poop branch simultaneously, run this command:
                  > git checkout -b poop
                  To checkout a previous snapshot, do the following:
                  > git log  (3 lines of text will display, similar to the 3 lines below.)
                    commit c9d66dd85f0b6891e5d3f29fc12750e6ca74ad9d
                    Author: TJB <w9mwi@yahoo.com>
                    Date:   Thu Jan 14 20:22:41 2016 -0600
                  > git checkout c9d66dd85f0b6891e5d3f29fc12750e6ca74ad9d  (Checkout the snapshot shown above.)
                  > git status
                  > git log
                  > git switch -  (This command cancels the above "git checkout c9d66dd85..." command.)
                  > git checkout main  (Returns to the main branch, effectively canceling the above "git checkout c9d66dd85..." command.)
                  > git checkout Version_1.0  (Checks out the "Version 1.0" tag.  For details, read the "TAG A RELEASE" section below.)

TAG A RELEASE     To tag a release, do the following:
                  > git checkout main
                  > git tag -a Version_1.0  -m "Tag Version 1.0"
                  You can now add/commit more files to the "Version 1.0" tag.  When you want to return to the "Version_1.0" tag,
                  run the following command instead of "git checkout c9d66dd8...", which involves the long, cumbersome ID number.
                  > git checkout Version_1.0

GIT REVERT        Undoes a previous commit by applying a new commit.  Undoes changes contained in one of the committed snapshots.
                  > git log
                  > git checkout main  (Choose a snapshot ID from the above "git log" command, and run the following:
                  > git revert b1b4e7a77fe1164952cad7699292024686c3357c  (The changes made in ID "b1b4e7a7..." will be undone.)

GIT RESET         NOTE: "git restore" is a NEW alternative command to "git reset", and should be used
                        instead of "git reset".  See "git restore" command below for details.

                  "git reset" undoes changes to the working directory and the staged snapshot.  Assume you
                  made text changes to an already-committed file named index.html AND you added a brand-new
                  file named "dummy.html".  If you decide to scrap those changes (that is, revert changes
                  made to index.html AND delete the "dummy.html" file), run the following 2 commands.
                  NOTE: Both of the following commands affect the WORKING DIRECTORY.  The "git reset" command also
                        reverts changes made to the STAGED SNAPSHOT, which is made via the "git add" command.
                        The following 2 commands DON'T change the contents of any committed snapshots.
                  > git reset --hard  (Resets tracked files to match the most recent commit.)
                  > git clean -f  (Deletes the "dummy.html" file from the working directory.)
                  The above 2 (TWO) commands together permanently undoes uncommitted changes.

GIT RESTORE       NOTE: The "git restore" command was introduced in git Version 2.23.0, and is an alternative
                  to the "git reset" command.  "git restore" can be a dangerous command because it can
                  permanently delete files.  Be careful how it's used.

                  Assume you’ve changed files named file_1 and file_2, and want to commit them as two separate changes.
                  However, you mistakenly ran "git add *" and staged both those files.  The following shows how
                  to unstage file_2.

                  > git add *  (You mistakenly staged the file named file_2.)
                  > git restore --staged file_2

GIT CLEAN         Assume you created a new file named dummy.html.  But you didn't add or commit it to git, which
                  means dummy.html is NOT tracked.  To remove this dummy.html file AND ALL UNTRACKED FILES, run:
                  > git clean -f  (Deletes all untracked files from the working directory.)

GIT SWITCH       The "git switch" command introduced was introduced in Git Version 2.23.  It's used mainly for
                 creating and switching branches.  It's an alternative to the "git checkout" command.

                 The below command includes the hyphen '-' character.  It cancels the last
                 "git checkout" command, and returns you to the previous branch.
                 > git switch -

GIT BRANCH       To view all local git branches on your computer (not remote branches),
                 run the following command.

                 > git branch

                 The above command displays text similar to the text below, where the
                 asterisk (*) designates the git branch that you're currently on.

                   verson_1_branch
                 * main

                 To create a new branch named poop, and then check it out, do the following.  This new poop branch will
                 initially be identical to the branch you currently have checked out.
                 > git branch poop
                 > git checkout poop
                 To create a new branch named poop, AND checkout this new poop branch simultaneously, run this command:
                 > git checkout -b poop

                 In Git, a branch is an independent line of development.  Branches present an error-proof method for
                 incorporating changes from an experiment.  Branches also let you store all of your experiments in a
                 single directory, which makes it much easier to keep track of them and to share them with others.
                 Creating a new branch is really just a way to request an independent working directory, staging
                 snapshot, and history.  There are four (4) core elements to work with throughout the rest of this tutorial:
                 1) The Working Directory
                 2) The Staged Snapshot
                 3) Committed Snapshots
                 4) Development Branches
                 When the "git branch" command creates a new branch, it uses the current HEAD NODE as the starting point
                 for the new branch.  This means the new branch begins as a copy of the existing branch--so it will contain
                 a copy of the existing branch's files located in the current working directory.
                 
                 Git uses the tip of a branch to represent the entire branch.  In other words, a branch is actually
                 a pointer to a single commit—-not a container for a series of commits.

                 The following command displays our one and only branch: * main.  The main branch is Git’s default
                 branch, and the asterisk next to it tells us that it’s currently checked out.  Notice that since
                 there’s only one working directory for each project, only one branch can be checked out at a time.
                 > git branch
                 * main  (This gets displayed when "git branch" is run.)
                 Next, check out a previous snapshot (514fbe7 referes to the ID of the crazy.html commit.)
                 > git checkout 514fbe7
                 From this, let's now create a new branch called "crazy":
                 > git branch crazy
                 And now, let's checkout this new "crazy" branch so we'll no longer be on the "main" branch.
                 > git checkout crazy
                 The new "crazy" branch is a completely isolated from the "main" branch, so we can
                 mess with files in this same working directory without changing any files on the "main" branch.

                 Rename crazy.html to rainbow.html, then use the following Git commands to update the repository.
                 > git status
                 > git rm crazy.html
                 > git status
                 > git add rainbow.html
                 > git status
                 > git commit -m "Rename crazy.html to rainbow.html"
                 The git rm command above tells Git to stop tracking crazy.html (and delete it if necessary), and the
                 git add command above starts tracking rainbow.html.  The renamed: crazy.html -> rainbow.html message
                 in the "git status" output shows us that Git is smart enough to figure out when we’re renaming a file.
                 Now, when we run "git branch", we see both branches (crazy and main) that exist:
                 > git branch
                     crazy
                   * main

DELETE BRANCH   To delete a branch named poop, run the following commands.

                > git branch -d poop  (-d deletes the branch ONLY if the branch is fully merged.
                                       -D deletes the branch regardless if the branch is unmerged or fully merged.)
                > git branch  (Confirm the poop branch is gone.)

GIT MERGE       The git merge command affects ONLY the branch that is currently checked out.

                > git checkout main  (Go to the main branch.)
                > git merge css  (Merge the css branch into the main branch.)

                Git can merge changes into any branch (not just the main branch).  We can pull the updates in with
                with the familiar git merge command.  Merging only affects the checked-out branch.  Now, merge the
                main branch into the crazy branch...
                > git checkout crazy
                > git merge main
                > git log --oneline

                There are simple merges, and there are "3-Way Merges".  A simple/regular merge PERFORMS ONE PARENT COMMIT.
                A 3-way merge occurs when you try to merge two branches that have a divergent history.  A 3-way merge
                PERFORMS TWO PARENT COMMITS.  Assume you have two branches--one named "main" and one named "development."
                To merge the "development" branch into the "main" branch you must be on the "main" branch.  The
                following 2 commands accomplish that.
                > git checkout main  (Ensure you're on the "main" branch.)
                > git merge development  (Merge the "development" branch into the "main "branch.) 
                Depending on the state of the "main" and "development" branch, the above "git merge"
                command could perform a simple merge or a 3-way merge.

                To better understand a "3-Way Merge" perform an Internet search on that term.  Here's one explanation:
                SEE --> https://www.tutorialspoint.com/what-is-3-way-merge-or-merge-commit-in-git

GIT REBASE    Rebasing allows you to move branches around by changing the commit that they are based on.
              (Thus the name rebase.)

              Git rebase requires you to be on the branch that you want to alter.  In this example,
              we must be on the 'about' branch.  Running the 'git rebase main' command will then
              alter the 'about' branch so its TAIL NODE will now connenct to the HEAD NODE of the
              'main' branch.
              > git checkout about
              > git rebase main

              An INTERACTIVE REBASE prompts the user with an opened text file, which can be edited to alter how the
              rebase performs.  If the user does NOT alter this text file, the rebase that occurs will be identical
              to running the 'git rebase' command WITHOUT the -i flag shown below.  To run an interactive rebase on
              the 'about' branch, do the following:
              > git checkout about
              > git rebase -i main  (The -i flag menas INTERACTIVE, so the user will be prompted to change behavior.)
              
              If you're in the middle of performing a rebase, and you get lost (not certain if what you're doing
              is correct), you can abort rebase in midstream by running the following command:
              > git rebase ‑‑abort

              Rebasing enables fast-forward merges by moving a branch to the tip of another branch.  It effectively
              eliminates the need for merge commits, resulting in a completely linear history.  To an outside observer,
              it will seem as though you created every part of your project in a neatly planned sequence, even though
              you may have explored various alternatives or developed unrelated features in parallel.  Rebasing gives
              you the power to choose exactly what gets stored in your repositories.

GIT REFLOG    Git uses something called the reflog to record every change you make to your repository.  The reflog is
              a chronological listing of repository history, without regard for the repository’s branch structure.
              This lets us find dangling commits that would otherwise be lost from the project history.  Run the
              following command, which will display a list of history:
              > git reflog

GIT RM - This command tells git to stop tracking a file.  Assume you're on some git branch and want to
         edit a file named crazy.html, and then rename that file to rainbow.html.  You would do this...

         Edit and save the crazy.html file.
         > mv crazy.html rainbow.html
         > git rm crazy.html    (Inform git to no longer track the crazy.html file)
         > git add rainbow.html
         > git commit -m "Added rainbow.html file and deleted the crazy.html file."

REMOTE REPOSITORIES  A remote repository is one that's not your own.  It can be another Git repository located
                     on your company’s network, the internet, or even on your own hard disk.  Remote branches
                     act just like local branches, except they represent a branch located in someone else’s repository.
                     Think of REMOTE BRANCHES AS READ-ONLY BRANCHES.   If you approve the changes a remote branch contains,
                     you can merge it into a local branch with a normal git merge. 

CLONING REPOSITORY  To clone an existing repository located on your hard disk, do the following...
                    On the command line, navigate to the PARENT DIRECTORY containing the repository
                    you want to clone.  In this example, the "C:\Tom\Programming" parent directory
                    contains the child directory "C:\Tom\Programming\my-git-repo".  So navigate to
                    the "C:\Tom\Programming" directory, then run the following commands:
                       > git clone my-git-repo  marys-repo  (The my-git-repo directory/repository gets cloned into the
                                                             marys-repo directory/repository.  This command also creates
                                                             the marys-repo directory.)
                       > cd marys-repo  (You are now in the newly-created repository directory named marys-repo.)
                       > git branch -rv (Verify that the only LOCAL BRANCH existing in marys-repo is the 'main'
                                         branch.)
                       > git remote -v  (Verify the marys-repo BRANCH does have a REMOTE REPOSITORY named 'origin'.  This
                                         REMOTE REPOSITORY named 'origin' was created via the above "git clone" command.)
                       > git config user.name "Mary"
                       > git config user.email w9mwi@yahoo.com
                    When you clone a repository, Git automatically adds an 'origin' REMOTE REPOSITORY to the newly-cloned
                    repository.

                    Next, navigate back to the "C:\Tom\Programming\my-git-repo" directory, and run the following commands:
                       > git remote -v (Notice that there exists no remote repository.)
                       > git remote add mary ../marys-repo   (Create a remote repository named 'mary', pointing to the
                                                              repository located in "C:\Tom\Programming\marys-repo")
                       > git remote -v  (The following 2 lines are output.)
                       mary    ../marys-repo (fetch)
                       mary    ../marys-repo (push)
                    IMPORTANT: From the "C:\Tom\Programming\marys-repo" directory, we can now reference the 'origin'
                               repository.
                    IMPORTANT: From the "C:\Tom\Programming\my-git-repo" directory, we can now reference the 'mary'
                               repository.

MERGING FROM ONE REPOSITORY INTO ANOTHER:
                    After you've completed all steps in the above CLONING REPOSITORY section, do the following
                    to merge code from the 'mary' repository (located in the 'marys-repo' directory) into the
                    'origin' repository (located in the 'my-git-repo' directory).
                    From the "C:\Tom\Programming\my-git-repo" directory, run these commands:
                       > git fetch mary  (Fetch all of the branches located in the marys-repo repository into
                                          the my-git-repo repository.)
                       > git branch -rv  (Displays all branches that exist in REMOTE REPOSITORIES, like the following
                                          2 lines.)
                         mary/bio-page
                         mary/main
                   Let's now checkout the mary/main branch (displayed immediately above) into the my-git-repo directory.
                       > git checkout mary/main  (Checkout the main branch from the mary repository,
                                                 so we can review code changes made by Mary.)
                       > git checkout main       (Checkout our own main branch, which overwrites the mary/main
                                                 branch that we just checked out in the previous command.)
                       > git merge mary/main     (Merge the mary/main branch into our main branch.)
FETCH AND PUSH    The fetch and push commands are almost opposites.  Fetch IMPORTS A BRANCH from a remote repository.
                  Push CREATES A NEW LOCAL BRANCH in a remote repository.  Navigate to the "C:\Tom\Programming\my-git-repo"
                  directory, and run the following 2 commands.
                  > git branch dummy     (Creates a new 'dummy' branch in the my-git-repo directory.)
                  > git push mary dummy  (Export the 'dummy' branch to the 'mary' repository.)
                  As a general rule, you should never push into another developer’s repository.  The reason "git push" exists
                  is that it allows you to make changes to a PUBLIC repository, that should be maintained by multiple people.
                  Next, navigate to the "C:\Tom\Programming\my-git-repo" directory, tag the main branch in this
                  directory, and then push this tagged v2.0 version to the 'mary' repository.
                  > git tag -a v2.0 -m "An even stabler version of the website"
                  > git push mary v2.0
                  Navigate to the "C:\Tom\Programming\marys-repo" directory, and run the following command.
                  > git tag  (The 'v2.0' tag should display.)
                  It’s very easy to forget to push new tags, so if it seems like your project has lost a tag or two,
                  it’s most likely because you didn’t to push them to the remote repository.
                  Note that "remotes" are for people.  "Branches" are for topics.  Do not create separate branches
                  for each of your developers—-give them separate repositories and bookmark them with git remote add.
                  Branches should always be for project development, not user management.  The 'git push' command works
                  ONLY if you cloned from a server to which you have write access, AND IF nobody has pushed in the
                  meantime.  If you and someone else clone at the same time, and they push upstream, and then later you
                  push upstream, your push will rightly be rejected.  You’ll have to pull down their work first and
                  incorporate it into yours before you’ll be allowed to push.

GIT FETCH         Since fetched content is represented as a remote branch, it has absolutely no effect on your local
                  development work. This makes fetching a safe way to review commits before integrating them with your
                  local repository. It’s similar to svn update in that it lets you see how the central history has
                  progressed, but it doesn’t force you to actually merge the changes into your repository.

                  SUMMARY...
                  > git clone <remote-path>  (Create a copy of a remote Git repository.)
                  > git remote -v  (List remote repositories.)
                  > git remote add <remote-name> <remote-path>  (Add a remote repository.)
                  > git remote show origin  (Show details about the remote branch named 'origin'.)
                  > git fetch <remote-name>  (Download remote branch information, but do not merge anything.)
                  > git merge <remote-name>/<branch-name>  (Merge a remote branch into the checked-out branch.)
                  > git branch -rv  (List remote branches.)
                  > git push <remote-name> <branch-name>  (Push a local branch to another repository.)
                  > git push <remote-name> <tag-name>     (Push a tag to another repository.)
CENTRALIZED WORKFLOWS
                  Running the below "git init" command creates a new repository directory named central-repo.git.  The
                  --bare flag indicates there will NOT be a working directory created for this repository.  If you navigate
                  to the C:\Tom\Programming\central-repo.git directory, you'll see it does NOT contain the standard
                  .git directory.  As a matter of fact, the files contained in this C:\Tom\Programming\central-repo.git
                  directory contain the same files that exist in the standard .git directory.  (That's why we this
                  directory name contains the ".git" extension.)  Not having a working directory prevents anyone
                  from developing in the central repository, which eliminates the possibility of messing up another
                  user’s environment with git push.  A central repository should act only as a storage facility--not
                  as a development environment.
                  > git init --bare central-repo.git
                  Add this new central repository (central-repo.git) as a REMOTE REPOSITORY to both the 'marys-repo' and
                  the 'my-git-repo' repositories by running the following commands:
                  > cd marys-repo  (Navigate to the C:\Tom\Programming\marys-repo directory).
                  > git remote rm origin  (Delete the existing remote repository named 'origin'.)
                  > git remote add origin ../central-repo.git  ('marys-repo' now references central-repo.git as 'origin'.)
                  > cd my-git-repo  (Navigate to the C:\Tom\Programming\my-git-repo directory).
                  > git remote add origin ../central-repo.git  ('my-git-repo' now references central-repo.git as 'origin'.)
                  > git remote rm mary  (Remove the existing 'mary' remote epository from my-git-repo.)
                  Now, push the main branch of the my-git-repo repository to the central-repo.git repository.
                  > cd C:\Tom\Programming\my-git-repo
                  > git push origin main  (The central-repo.git main branch gets a copy of the my-git-repo main
                                             branch.)
                  > cd C:\Tom\Programming\central-repo.git
                  > git log  (Confirm that the output of this log is identical to the log output on the my-git-repo
                              repository.
                  NOTE: The "git push" command creates a local branch in the destination repository.  It's dangerous to
                        push to a friend’s repository, as she probably won’t appreciate other programmers creating new
                        branches in her working directory without her consent.   However, it’s safe to create local
                        branches in central-repo.git because it has no working directory, which means it’s impossible
                        to disturb anyone’s development.
                  WARNING:  NEVER rebase commits that have been pushed to a shared repository.  If you need to change
                            a public commit, use the "git revert" command discussed previously.
DISTRIBUTED WORKFLOWS
                  Run the following commands:
                  > cd C:\Tom\Programming\my-git-repo
                  > git remote rm  origin  (Delete the existing remote 'origin' branch from the my-git-repo directory.)
                  > git remote add origin https://github.com/w9mwi/my-git-repo.git  (Point the remote 'origin' repository
                                                                                     to GitHub.)
                  > git push origin main  (Push my-git-repo's main branch to the remote 'origin' (GitHub) branch.
                  Create a repository for co-worker John:
                  > cd C:\Tom\Programming
                  > git clone  https://github.com/w9mwi/my-git-repo.git  johns-repo  (johns-repo will contain our
                                                                                      GitHub contents.)
                  > cd johns-repo
                  > git config user.name "John"
                  > git config user.email junk@shit.com
                  > git checkout -b pink-page  (Creates a new branch named pink-page, and then does a checkout on pink-page.)
                  Add a new repository to GitHub named 'johns-repo' via the GitHub web site.  Next, on your hard disk, inside
                  the C:\Tom\Programming\johns-repo directory, run the following command to create a new remote repository
                  named 'john-public', which will point to the new 'johns-repo' repository on GitHub.
                  > git remote add  john-public  https://github.com/w9mwi/johns-repo.git
                  From the C:\Tom\Programming\johns-repo directory, make certain you have the 'pink-page' branch checked out.
                  Then, push the pink-page local branch to the 'john-public' remote branch that's located on GitHub...
                  > cd C:\Tom\Programming\johns-repo
                  > git checkout pink-page
                  > git push john-public pink-page  (Creates new 'pink-page' repository from GitHub in
                                                     C:\Tom\Programming\johns-repo)
                  In the my-git-info directory, add a new remote repository named 'john' that points to 'johns-repo'
                  in GitHub...
                  > cd C:\Tom\Programming\my-git-repo
                  > git remote add john  https://github.com/w9mwi/johns-repo.git
                  > git fetch john  (Copies contents of GitHub's 'johns-repo' repository to the new 'john' repository.)
                  > git branch -rv  (Shows the new john/pink-page remote repository.)
                  > git checkout john/pink-page  (Checkout the 'pink-page' repository located in
                                                  C:\Tom\Programming\johns-repo)
                  If you approve John's updates, merge them into your main branch (in the my-git-repo directory).
                  > git checkout main
                  > git merge john/pink-page
                  Finally, push your main branch to the 'origin' GitHub 'my-git-repo' repository, which corresponds
                  to your 'my-git-repo' working directory.
                  > git push origin main
                  Do the following on the 'marys-repo' branch.
                  > cd C:\Tom\Programming\marys-repo
                  > git remote rm origin  (Delete the previous 'origin' branch, as we make a new one that points to GitHub.)
                  > git remote add origin  https://github.com/w9mwi/my-git-repo.git  (Creates new 'origin' branch pointing
                                                                                      to GitHub.)
                  > git checkout main
                  > git fetch origin  (Copies contents of GitHub's 'my-git-repo' repository to the new 'origin' repository.)
                  > git rebase origin/main
                  Update johns-repo on your hard disk, similar to what we did with marys-repo above.
                  > cd C:\Tom\Programming\johns-repo
                  > git checkout main
                  > git fetch origin
                  > git rebase origin/main

PATCH WORKFLOWS  Add a remote branch named 'origin' to BOTH the my-git-repo and the marys-repo repositories.
                 Both these remote branches named 'origin' will point to the same remote repository.
                 > cd C:\Tom\Programming\my-git-repo
                 > git remote add origin https://github.com/w9mwi/my-git-repo.git
                 > cd C:\Tom\Programming\marys-repo
                 > git remote add origin https://github.com/w9mwi/my-git-repo.git

TIPS AND TRICKS
                 Archive the 'main' repository in the 'my-git-repo' directory (not including the .git directory).
                 Removing the .git directory removes all version control information, and you’re left with a single
                 snapshot of your project.
                 > cd C:\Tom\Programming\my-git-repo
                 > git archive main --format=zip --output=../website-12-10-2012.zip  (On Windows)
                 > git archive main --format=tar --output=../website-12-10-2012.tar  (On UNIX)
                 You can also bundle a repository, which is similar to the above 'archive' command, except the resulting
                 file does contain the .git directory (versioning information of the entire project).  In this example,
                 we bundle the 'main' branch of the 'my-git-repo' directory.
                 > git bundle create ../repo.bundle main  (Saves 'main' branch of the repository to the repo.bundle file.)
                 Navigate to the directory containing the repo.bundle file created in the above command, and run the
                 following:
                 > git clone repo.bundle repo-copy -b main  (Creates a cloned repository in a child directory named 'repo-copy'.)
                 Use the bundle command above to backup an entire Git repository.
                 MAKE GIT IGNORE FILES
                 To make Git ignore certain files, you can do the following:
                 > notepad junkfile.txt  (Create a new file called 'junkfile.txt' and save it in the 'my-git-repo' directory.)
                 > git status  (Notice the junkfile.txt appears as an untracked file.)
                 In the same 'my-git-repo' directory, create a new file called .gitignore and enter this text into it:
                 junkfile.txt
                 > git status (junkfile.txt no longer appears as an untracked file, but the .gitignore file does!
                               Fix that here...)
                 > git add .gitignore
                 > git commit -m "Add .gitignore file"
                 > git status  (Notice there are no more untracked files.)
                 
                 

PLUMBING
                  Running the following command will output the complete representation of a commit, which consists of:
                  Tree + Parent + User Data + Commit Message
                  > git cat-file commit HEAD
                  A tree object is Git’s representation of the “snapshots”. A snapshot records the state of a directory
                  at a given point, without any notion of time or author.  To tie trees together into a coherent project
                  history, Git wraps each one in a commit object and specifies a parent, which is just another commit.
                  By following the parent of each commit, you can walk through the entire history of a project.
                  Run the below commands
                  > git log --oneline  (Obtain an ID number used by the following comand.)
                  > git cat-file tree 781e5cd  (Notice output contains ugly binary cruft.)
                  > git ls-tree 781e5cd        (Output looks much cleaner than above command.)
                  Regarding the output of the above 2 commands: a 'blob' represents a file, a 'tree' represent a folder.
                  Since a blob represents a file, obtain an ID number from the following command that represents a blob.
                  > git cat-file blob 3c13974  (Obtain a an ID from one of the blob files that display.)
                  > git cat-file blob 30560188ea822a5c0fe050eccac16d8ffe47e470  (Prints file contents.)
                  IMPORTANT: A detached HEAD state occurrs when HEAD doesn't coincide with the tip of any branch.
                  Run the following to see this...
                  > git checkout HEAD~1
                  > git status  (You should see a message siminar to this:  HEAD detached at 1287d48)
                  > git checkout main
                  > git status  (The 'HEAD detached' message above should now be gone.)
HOOKS             Read section titled 'Hook into Git’s Internals' on this web page:
                  http://rypress.com/tutorials/git/tips-and-tricks
                  Navigate to the ./git/hooks directory in your repository folder.  You will notice about 9 file names that
                  end with the .sample extension.  These are shell script files.  When the '.sample' extension is removed
                  from these file names, these files will execute the shell script contents of these files.
VIEW DIFFS BETWEEN COMMITS
                  The git diff command is incredibly useful for pinpointing contributions from other developers.  EXAMPLES:
                  > git diff  (Generates a detailed view of all uncommitted changes.)
                  > git diff --cached  (The --cached flag generates a diff between the staged snapshot and most-recent
                                        commit.)
                  > git diff HEAD~2..HEAD~1
                  > git diff main..john/pink-page

========================================================================================================================
========================================================================================================================
HOW TO PUSH YOUR LOCAL HARD DISK REPOSITORY FILES TO A REMOTE GITHUB REPOSITORY
-------------------------------------------------------------------------------

1) Create a new repository on GitHub named tomsJunkRepo, and leave it empty.
2) Run the following:
   > cd C:\Tom\Programming  (The local hard disk directory that will contain your new local repository.)
   > mkdir tomsJunkRepo
3) In the tomsJunkRepo directory, create the .gitignore file, create some other files, and create some files in a
   child directory.  Then create a new 'main' branch in your local repository by running the following commands:
   > cd C:\Tom\Programming\tomsJunkRepo
   > git init  (Creates your local Git repository.)
   > git status (Confirm your local repository was created.)
   > git add .  ...OR...   > git add *   (Adds all untracked files to staging area.)
   > git status (Confirm your files and child directories were added/staged.)
   > git branch -v (Confirm there does NOT yet exist a local branch.)
   > git commit -m "Initial commit."
   > git status  (Confirm the above 'git commit' command has created a branch named 'main'.)
   > git branch -v  (Confirm you're now on this 'main' branch.)
4) Create a new remote repository named 'origin', which will point to your GitHub repository designated by the URL below.
   > git remote -v  (Confirm that there does NOT yet exist any remote repositories.)
   > git remote add origin  https://github.com/w9mwi/tomsJunkRepo.git  (VIA URL, adds a new remote repository named
                                                                        'origin'.)
   > ...OR...
   > git remote add origin  git@github.com:w9mwi/tomsJunkRepo.git  (VIA SSH, adds a new remote repository named 'origin'.
                                                                    Generate new SSH key:
                                                                    https://help.github.com/articles/generating-a-new-ssh-key)
   > git remote -v  (Confirm there now exists a remote repository named 'origin'.)
5) Look at the contents of the 'tomsJunkRepo' repository on your github.com web page, and notice it does NOT contain
   any of the files/directories contained in your local 'tomsJunkRepo' repository.
6) Push the contents of your local 'tomsJunkRepo' repository to the GitHub web site by running the following commands:
   > git branch -rv (Confirm there does NOT yet exist any remote branches--even though the 'origin' remote repository
                     does exist.)
   > git push origin main  (Push the contents of your local 'main' branch to the 'origin' remote repository.)
   > git branch -rv  (Confirm that there now exists a REMOTE repository/branch named origin/main.)
   > git remote show origin  (Prints details about the remote 'origin' repository, similar to the following 8 lines of text.)
     * remote origin
       Fetch URL: https://github.com/w9mwi/tomsJunkRepo.git
       Push  URL: https://github.com/w9mwi/tomsJunkRepo.git
       HEAD branch: main
       Remote branch:
         main tracked
       Local ref configured for 'git push':
         main pushes to main (local out of date)
7) Look at the contents of the 'tomsJunkRepo' repository on your github.com web page, and notice it now DOES CONTAIN
   the files/directories contained in your local 'tomsJunkRepo' repository.
8) THE END - Your local 'main' branch has successfuly been pushed to the 'main' branch of the REMOTE repository named 'origin'.

HOW TO FETCH+MERGE FILES CHANGES MADE ON GITHUB TO YOUR LOCAL 'MAIN' BRANCH
-----------------------------------------------------------------------------
1) Change some text in your files on GitHub.  We'll now fetch+merge these GitHub files to the corresponding files
   on your local 'main' branch.
> git checkout main  (Make certain you're on the local 'main' branch.)
> git remote show origin  (Show details about the remote 'origin' repository.)
> git fetch origin     (Import file changes made on 'origin' remote repo. to your local 'main' branch.
                        NOW DO A GIT MERGE...)
> git merge origin/main  (Only after you run this command will you notice that your files on the local 'main' branch
                            now reflect the files located on GitHub.)
2) THE END - File changes made on the GitHub web site have now been fetched+merged into your local 'master' branch.



HOW TO PUSH FILE CHANGES MADE ON YOUR LOCAL 'MAIN' BRANCH TO THE GITHUB WEB PAGE.)
------------------------------------------------------------------------------------
> checkout main  (Make certain you're on the local 'main' branch.)
1) Change content of some files on your local 'main' branch, then run the following commands:
   > git status  (Shows the files that you changed.)
   > git add .  (Stage the changed files.)
   > git commit -m "Modified the 4 text files."
   > git status  (Verify all the repository is "clean", which means all files have been committed.)
   > git push origin main
2) Verify that all files changed on your local 'main' branch have been pushed to the GitHub web page.
3) THE END

========================================================================================================================
========================================================================================================================



========================================================================================================================
========================================================================================================================
GIT COMMANDS - GIT COMMANDS - GIT COMMANDS - GIT COMMANDS - GIT COMMANDS - GIT COMMANDS

An UNTRACKED FILE is a file that's never had the "git add" command run on it.
A TRACKED FILE is a file that has had the "git add" command run on it at least one time.
A STAGED FILE is a file that has NOT been altered/changed since it was last committed via the "git commit" command.
Every time you make a change to a STAGED FILE, you must again run the "git add" command on it before it can
be committed via the "git commit" command.

GIT CHECKOUT BRANCHES
> git checkout main  (The repository points to the 'main' branch.)
> git checkout poop    (The repository points to the 'poop' branch.)
> git log --oneline  (Prints something similar to below text.)
  6715fc5 Added whitespace to blue.html file.
  430d978 Add .gitignore file
  49f80f3 Changed index.html, added news4.html.
  fe17adf Add pink page
  1287d48 Add CSS styles for headings and links
> git checkout 49f80f3  (This makes your working directory match the exact state of the 49f80f3 commit.  HEAD no longer
                         points to a branch, but to a previous commit deignated by the 49f80f3 ID.  This is called a
                         “detached HEAD” state.)
> git checkout 6715fc5 blue.html  (Checks out the blue.html file that was in the 6715fc5 commit.  This can change the
                                   current state of your project.  You can add + commit this olded blue.html file,
                                   or run the following command to revert that file back to its current state.)
> git checkout HEAD blue.html     (Returns contents of blue.html file to the one in the most-recent commit.)


GIT CHECKOUT A FILE
> git checkout fe17adf hello.py

GIT PUSH - The most common use case for git push is to publish your local changes to a central repository.  After you’ve
           accumulated several local commits and are ready to share them with the rest of the team, you (optionally)
           clean them up with an interactive rebase, then push them to the central repository.
           'git push' is how you transfer commits from your local repository to a remote repo.  It's the counterpart
           to git fetch.  But whereas 'GIT FETCH' IMPORTS COMMITS TO LOCAL BRANCHES, 'GIT PUSH' EXPORTS COMMITS TO
           REMOTE BRANCHES.  'GIT PUSH' HAS THE POTENTIAL TO OVERWRITE CHANGES, so you need to be careful how you
           use it.  To prevent you from overwriting commits, Git won’t let you push when it results in a
           non-fast-forward merge in the destination repository.   'git push' is essentially the same as running
           'git merge main' from inside the remote repository.   You should only push to repositories that have
           been created with the --bare flag.  Since pushing messes with the remote branch structure, it’s important
           to never push to another developer’s repository.  But because 'bare' repos do NOT have a working
           directory, it’s impossible to interrupt anybody’s developments.

GIT PULL - It is NOT recommended that you use "git pull" because it can make changes that you don't want.
           Instead, you should use the "git fetch" command followed by the "git merge" command to ensure the
           changes you're making are correct.  As using "git pull" alone may perform a merge that you don't
           want.  To learn more, search the web for:  "git difference between pull and merge"

REMOVE FILE FROM STAGED AREA:  (Seems to do the same thing as "git reset HEAD tom.java" below.)
> git add tom.java
> git rm --cached tom.java  (Removes tom.java from staged area, but doesn't delete the file.)
> del tom.java  (If you want to permanently delete the file.)

REMOVE FILE FROM STAGED AREA:  (Seems to do the same thing as "git rm --cached tom.java" above.)
> git add tom.java
> git reset HEAD tom.java  (Removes tom.java from staged area, but doesn't delete the file.)

DELETE A STAGED FILE:
> git add tom.java
> git rm tom.java

CHANGE ALTERED FILE TO ITS COMMITTED STATE:
Assume the working directory is clean and up to date with the most recent commit,
and you mistakenly do one of the following:
1) Change a file that's previously been committed (in this example blue.html).
2) Change a file that's previously been committed (in this example blue.html), and then "git add" the blue.html file.
To bring back the original blue.html file that's already committed, run the following command:
> git checkout HEAD blue.html

DISPLAY ALL REMOTE REPOSITORIES FROM YOUR CURRENT REPOSITORY.
> git branch -rv   (Displays information similar to the following 3 lines.)
  john-public/pink-page fe17adf Add pink page
  origin/HEAD           -> origin/main
  origin/main         fe17adf Add pink page


RESET TRACKED FILES TO MOST-RECENT COMMIT - Undoes changes to the working directory and the staged snapshot.
                                            Assume you made text changes to an already-committed file named: index.html
                                            To revert your changes made to index.html, do the following:
                                            > git reset --hard
                                            > git clean -f

DELETE ALL UNTRACKED FILES - Assume you created a new file named dummy.html.  But you didn't add or commit it to git, which
                             means dummy.html is NOT tracked.  To remove this dummy.html file AND ALL UNTRACKED FILES, run:
                             > git clean -f  (Remove all untracked files.)

CHANGE MESSAGE OF MOST-RECENT COMMIT:
> git add tom.java
> git commit -m "Commited tom.java file."
> git commit --amend  (Change message in the pop-up editor.)

RENAME A COMMITTED FILE:
> git add tom.java
> git commit -m "Added tom.java file."
> git mv tom.java  jack.java  (Renames tom.java to jack.java)
> git add jack.java
> git commit -m "Added jack.java file."

REMOVE A BRANCH:
> git branch -d poop  (Removes the brnch named 'poop')

MERGE A BRANCH
> git checkout main  (Go to the main branch.)
> git merge css  (Merge the css branch into the main branch.)

REMOVE A REMOTE REPOSITORY:
> git remote rm john-public  (Remove the remote repository reference, but the remote repository remains.)

RENAME A REMOTE REPOSITORY:
> git remote rename <old-name> <new-name>

LOG FILE COMMANDS:
> git log --pretty=online
> git log --pretty=format:"%h : %an : %ar : %s"  (Colon chars optional.)
> git log -p -2  (Show last 2 commits.)
> git log --stat
> git log --since=1.weeks  (Shows all changes made in the last 1 week.)
> git log --since="2016-01-20"
> git log --before="2016-01-20"
> git log --author="TJB"

YouTube Git Tutorials --> https://www.youtube.com/watch?v=r63f51ce84A
                      --> https://www.youtube.com/watch?v=HVsySz-h9r4
